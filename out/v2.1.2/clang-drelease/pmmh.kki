module interface pmmh
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core/hnd = std/core/hnd = "";
private import std/core = std/core = "";
private import std/num/random = std/num/random = "";
private import effects-and-types = effects-and-types = "";
private import handlers = handlers = "";
private import sampling = sampling = "";
private import sequential = sequential = "";
private import trace = trace = "";
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
local alias effects-and-types/histogram<a> :: V -> V = (std/core/list :: V -> V)<(effects-and-types/exp, a)> = 1;
local alias effects-and-types/model<a,(e :: E)> :: (V, E) -> V = () -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>|(e :: E)> a = 1;
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure :: E = <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/div :: X)> = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// monadic lift
private fun .mlift117-new_model : forall<(e :: E),a> (params : a, wild_ : ()) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)> a;
// monadic lift
private fun .mlift118-new_model : forall<(e :: E),a,b> (params : b, smc_hist : (effects-and-types/histogram :: V -> V)<a>) -> <(std/core/pure :: E),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)> b;
// monadic lift
private fun .mlift119-new_model : forall<(e :: E),a,b> (main_model : (b) -> (effects-and-types/model :: (V, E) -> V)<a,<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/yield :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>>, particle_num : std/core/types/int, step_num : std/core/types/int, params : b) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)> b;
public fun new_model : forall<a,b,(e :: E)> (param_model : (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>, main_model : (a) -> (effects-and-types/model :: (V, E) -> V)<b,<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/yield :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>>, particle_num : std/core/types/int, step_num : std/core/types/int) -> (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>;
public fun pmmh : forall<a,b,(e :: E)> (param_model : (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>, main_model : (a) -> (effects-and-types/model :: (V, E) -> V)<b,<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/yield :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>>) -> <(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)> ((std/core/list :: V -> V)<((std/core/list :: V -> V)<std/core/types/double>, a)>, (trace/trace :: (V, E) -> V)<a,<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>);
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun pmmh // inline size: 5
  = forall<a,b,(e :: E)> fn<<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>>(param_model: (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>, main_model: (a) -> (effects-and-types/model :: (V, E) -> V)<b,<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/yield :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>>){
    val pmmh_model : (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>
          = val w : (std/core/hnd/evv :: E -> V)<(std/core/types/(<>) :: E)>
              = std/core/hnd/evv-swap-create0();
            val x : (effects-and-types/model :: (V, E) -> V)<a,<(std/core/pure :: E),(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>
              = pmmh/new_model<a,b,(e :: E)>(param_model, main_model, 10, 10);
            val keep : ()
              = std/core/hnd/evv-set<<(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>|(e :: E)>,(std/core/types/(<>) :: E)>(w);
          x;
    trace/tmcmc<a,<(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/types/ndet :: X),(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>|(e :: E)>>(pmmh_model, 10, (effects-and-types/Exp(0.0)), 0);
  };