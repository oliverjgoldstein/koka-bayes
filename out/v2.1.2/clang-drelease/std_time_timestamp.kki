/* Low level time spans and time stamps.

These are unit-less and may not necessarily be in (TAI) SI seconds, and
are used internally to do time scale conversions and calendar calculations.
User code should use `:std/time/duration/duration`s and `:std/time/instant/instant`s instead.
*/
module interface std/time/timestamp
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core = std/core = "";
private import std/num/int32 = std/num/int32 = "";
private import std/num/ddouble = std/num/ddouble = "";
private import std/time/date = std/time/date = "";
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// Time spans are a time duration in some time scale represented as a `:ddouble`;
// this gives it very high precision and range to represent time very precisely.
// (see the [`instant`](std_time_instant.html) module)
public alias timespan = std/num/ddouble/ddouble = 1;
/* A time stamp denotes an instant in time since 2000-01-01 in some time scale.
Time stamps also keep track of possible leap seconds for
UTC based timescales. [Unix/UTC seconds](https://en.wikipedia.org/wiki/Unix_time).


- One way is as a duration in TAI SI seconds
  but that would lead to many unnecessary conversions (and loss of precision),
  for example for unix timestamps that need adjustments for leap seconds.
- To avoid conversions, it is better to represent as days plus the seconds
  into that day. However, that means that adding or subtracting seconds
  always needs normalization.
- To make it easier to add/substract time spans, we can represent it as single
  timespan `since` where `days == floor(since / 86400)` and `seconds == since - days`.
  This is essentially the representation that Unix/Posic timestamps use too.
- Finally, we add a separate `leap` seconds field
  to represent time in a leap step unambigiously (and also at any time during the day).
  The `leap` field is positive if this time is in a leap step.

Here is the representation of a time in the leap second just before 2006-01-01:
```
time(2005,12,31,23,59,60,0.5).instant.timestamp.ts-show == "189388799.500 (+1 leap)"
time(2005,12,31,23,59,60,0.5).instant.timestamp.ts-show-days == "2191d 86399.500s (+1 leap)"
```
The `leap` field also lets us represent leap times that occurred at another
time than the last second of the day:
```
time(1959,1,28,18,59,59,0.01).instant.timestamp.ts-show-days == "-14948d 68399.010s"
time(1959,1,28,18,59,60,0.01).instant.timestamp.ts-show-days == "-14948d 68399.010s (+1 leap)"
time(1959,1,28,19, 0, 0,0.01).instant.timestamp.ts-show-days == "-14948d 68400.010s"
```
See `std/time/utc` for more information on leap seconds.

*/
public value{20,0} type timestamp {
  /* A time stamp denotes an instant in time since 2000-01-01 in some time scale.
Time stamps also keep track of possible leap seconds for
UTC based timescales. [Unix/UTC seconds](https://en.wikipedia.org/wiki/Unix_time).


- One way is as a duration in TAI SI seconds
  but that would lead to many unnecessary conversions (and loss of precision),
  for example for unix timestamps that need adjustments for leap seconds.
- To avoid conversions, it is better to represent as days plus the seconds
  into that day. However, that means that adding or subtracting seconds
  always needs normalization.
- To make it easier to add/substract time spans, we can represent it as single
  timespan `since` where `days == floor(since / 86400)` and `seconds == since - days`.
  This is essentially the representation that Unix/Posic timestamps use too.
- Finally, we add a separate `leap` seconds field
  to represent time in a leap step unambigiously (and also at any time during the day).
  The `leap` field is positive if this time is in a leap step.

Here is the representation of a time in the leap second just before 2006-01-01:
```
time(2005,12,31,23,59,60,0.5).instant.timestamp.ts-show == "189388799.500 (+1 leap)"
time(2005,12,31,23,59,60,0.5).instant.timestamp.ts-show-days == "2191d 86399.500s (+1 leap)"
```
The `leap` field also lets us represent leap times that occurred at another
time than the last second of the day:
```
time(1959,1,28,18,59,59,0.01).instant.timestamp.ts-show-days == "-14948d 68399.010s"
time(1959,1,28,18,59,60,0.01).instant.timestamp.ts-show-days == "-14948d 68399.010s (+1 leap)"
time(1959,1,28,19, 0, 0,0.01).instant.timestamp.ts-show-days == "-14948d 68400.010s"
```
See `std/time/utc` for more information on leap seconds.

*/
  private con Timestamp(since: (timespan == 1 std/num/ddouble/ddouble), leap32: std/core/types/int32) : (since : (timespan == 1 std/num/ddouble/ddouble), leap32 : std/core/types/int32) -> timestamp;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `since` constructor field of the `:timestamp` type.
private fun since : (timestamp : timestamp) -> timespan;
// Automatically generated. Retrieves the `leap32` constructor field of the `:timestamp` type.
private fun leap32 : (timestamp : timestamp) -> std/core/types/int32;
public fun .copy : (timestamp, since : (std/core/types/optional :: V -> V)<timespan>, leap32 : (std/core/types/optional :: V -> V)<std/core/types/int32>) -> timestamp;
public fun leap : (t : timestamp) -> std/core/types/int;
// Seconds in a solar day, 86400.
public val isolar-secs-per-day : std/core/types/int;
// Divide using `div` to allow for different timespan representations
public fun div : (x : timespan, y : timespan, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> timespan;
// The time span since 2000-01-01 for time scales that do not have
// leap seconds and where every day is 86400s. For time scales
// with leap seconds, this effectively ignores any leap seconds.
public fun timespan-noleap : (ts : timestamp) -> timespan;
// A zero-valued timespan.
public val timespan0 : timespan;
// Compare two `:timestamp`s.
public fun compare : (i : timestamp, j : timestamp) -> std/core/types/order;
public fun (!=) : (i : timestamp, j : timestamp) -> std/core/types/bool;
// Add a time span to a time stamp.
public fun (+) : (ts : timestamp, t : timespan) -> timestamp;
// Create a time stamp from a `:timespan` since 2000-01-01 and possible leap seconds.
public fun timestamp : (t : timespan, leap : (std/core/types/optional :: V -> V)<std/core/types/int>) -> timestamp;
// Create a time stamp from an integer timespan since 2000-01-01 and possible leap seconds.
public fun timestamp.1 : (t : std/core/types/int, frac : (std/core/types/optional :: V -> V)<std/core/types/double>, leap : (std/core/types/optional :: V -> V)<std/core/types/int>) -> timestamp;
// Subtract a time span from a time stamp.
public fun (-) : (ts : timestamp, t : timespan) -> timestamp;
public fun (==) : (i : timestamp, j : timestamp) -> std/core/types/bool;
public fun (<) : (i : timestamp, j : timestamp) -> std/core/types/bool;
public fun (<=) : (i : timestamp, j : timestamp) -> std/core/types/bool;
public fun (>) : (i : timestamp, j : timestamp) -> std/core/types/bool;
public fun (>=) : (i : timestamp, j : timestamp) -> std/core/types/bool;
public fun timespan : (seconds : std/core/types/int, frac : (std/core/types/optional :: V -> V)<std/core/types/double>) -> timespan;
public fun timespan.1 : (secs : std/core/types/double) -> timespan;
// Timespan from a `:ddouble`. Just for convenience as `:timespan` is an alias
public fun timespan.2 : (secs : std/num/ddouble/ddouble) -> timespan;
// Add `days` days to a timestamp
public fun add-days : (ts : timestamp, days : std/core/types/int) -> timestamp;
// Add `leaps` leap seconds to the timestamp.
public fun add-leap-seconds : (ts : timestamp, leaps : timespan) -> timestamp;
// Return days and seconds into the day, disregarding leap seconds.
public fun days-seconds : (ts : timestamp) -> (std/core/types/int, std/num/ddouble/ddouble);
public fun days : (ts : timestamp) -> std/core/types/int;
// Return days and clock into the day, handling possible leap seconds.
public fun days-clock : (ts : timestamp) -> (std/core/types/int, std/time/date/clock);
// The maximum of two timestamps.
public fun max : (i : timestamp, j : timestamp) -> timestamp;
// The minimum of two timestamps.
public fun min : (i : timestamp, j : timestamp) -> timestamp;
// Round a time stamp to a certain precision (`prec` is number of digits of the fraction of the second).
public fun round-to-prec : (t : timestamp, prec : std/core/types/int) -> timestamp;
public fun seconds-into-day : (ts : timestamp) -> std/num/ddouble/ddouble;
public val solar-secs-per-day : timespan;
// Timestamp from days, seconds into the day and possible leap second.
public fun timestamp-days : (days : std/core/types/int, secs : (std/core/types/optional :: V -> V)<timespan>, leap : (std/core/types/optional :: V -> V)<std/core/types/int>) -> timestamp;
// The time stamp at 2000-01-01
public val timestamp0 : timestamp;
// Show a time stamp.
public fun ts-show : (ts : timestamp, max-prec : (std/core/types/optional :: V -> V)<std/core/types/int>, secs-width : (std/core/types/optional :: V -> V)<std/core/types/int>, unit : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a day stamp
public fun ts-show-days : (ts : timestamp, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// The time span since 2000-01-01 including time inside a possible leap second.
public fun unsafe-timespan-withleap : (ts : timestamp) -> timespan;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline fun since // inline size: 0
  = fn(timestamp: timestamp){
    match (timestamp) {
      ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
         -> .x;
    };
  };
inline fun leap32 // inline size: 0
  = fn(timestamp: timestamp){
    match (timestamp) {
      ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat1: std/core/types/double) : std/core/types/double, (.pat2: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat0: timespan) : timespan, (.x: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: timestamp, since: (std/core/types/optional :: V -> V)<timespan>, leap32: (std/core/types/optional :: V -> V)<std/core/types/int32>){
    std/time/timestamp/Timestamp((match (since) {
        ((std/core/types/Optional((.since.78: timespan) : timespan) : (std/core/types/optional :: V -> V)<timespan> ) as .pat: ((std/core/types/optional :: V -> V)<timespan>))
           -> .since.78;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<timespan> ) as .pat0: ((std/core/types/optional :: V -> V)<timespan>))
           -> (match (.this) {
            ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.pat10: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat1: timestamp)
               -> .x;
          });
      }), (match (leap32) {
        ((std/core/types/Optional((.leap32.84: std/core/types/int32) : std/core/types/int32) : (std/core/types/optional :: V -> V)<std/core/types/int32> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/int32>))
           -> .leap32.84;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int32> ) as .pat20: ((std/core/types/optional :: V -> V)<std/core/types/int32>))
           -> (match (.this) {
            ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat12: std/core/types/double) : std/core/types/double, (.pat21: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat01: timespan) : timespan, (.x0: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
               -> .x0;
          });
      }));
  };
fun leap // inline size: 1
  = fn(t: timestamp){
    std/core/int.1((match (t) {
      ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat1: std/core/types/double) : std/core/types/double, (.pat2: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat0: timespan) : timespan, (.x: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
         -> .x;
    }));
  };
inline val isolar-secs-per-day // inline size: 0
  = 86400;
fun div // inline size: 1
  = fn(x: timespan, y: timespan, prec: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/num/ddouble/(/)(x, y);
  };
inline fun timespan-noleap // inline size: 0
  = fn(ts: timestamp){
    match (ts) {
      ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
         -> .x;
    };
  };
inline val timespan0 // inline size: 0
  = std/num/ddouble/Ddouble(0.0, 0.0);
fun (!=) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3756 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.3756)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (+) // inline size: 2
  = fn(ts: timestamp, t: timespan){
    std/time/timestamp/Timestamp((std/num/ddouble/(+)((match (ts) {
          ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
             -> .x;
        }), t)), (match (ts) {
        ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat10: std/core/types/double) : std/core/types/double, (.pat20: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat00: timespan) : timespan, (.x0: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
           -> .x0;
      }));
  };
fun timestamp // inline size: 3
  = fn(t: timespan, leap: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/time/timestamp/Timestamp(t, (std/core/int32((match (leap) {
        ((std/core/types/Optional((.leap.492: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .leap.492;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 0;
      }))));
  };
fun timestamp.1 // inline size: 9
  = fn(t: std/core/types/int, frac: (std/core/types/optional :: V -> V)<std/core/types/double>, leap: (std/core/types/optional :: V -> V)<std/core/types/int>){
    val t0.3760 : timespan
      = std/num/ddouble/(+)((std/num/ddouble/ddouble.1(t)), (std/num/ddouble/Ddouble((match (frac) {
            ((std/core/types/Optional((.frac.521: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/double>))
               -> .frac.521;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/double>))
               -> 0.0;
          }), 0.0)));
    val leap0.3761 : (std/core/types/optional :: V -> V)<std/core/types/int>
      = std/core/types/Optional<std/core/types/int>((match (leap) {
        ((std/core/types/Optional((.leap.525: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .leap.525;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 0;
      }));
    std/time/timestamp/Timestamp(t0.3760, (std/core/int32((match (leap0.3761) {
        ((std/core/types/Optional((.leap.492: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .leap.492;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 0;
      }))));
  };
fun (-) // inline size: 3
  = fn(ts: timestamp, t: timespan){
    std/time/timestamp/Timestamp((std/num/ddouble/(+)((match (ts) {
          ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
             -> .x;
        }), (std/num/ddouble/(~)(t)))), (match (ts) {
        ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat10: std/core/types/double) : std/core/types/double, (.pat20: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat00: timespan) : timespan, (.x0: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
           -> .x0;
      }));
  };
fun (==) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3767 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.3767)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3769 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.3769)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<=) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3771 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.3771)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3773 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.3773)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>=) // inline size: 6
  = fn(i: timestamp, j: timestamp){
    val x.3775 : std/core/types/order
          = std/time/timestamp/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.3775)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun timespan // inline size: 8
  = fn(seconds: std/core/types/int, frac: (std/core/types/optional :: V -> V)<std/core/types/double>){
    match ((std/core/(==.2)((match (frac) {
        ((std/core/types/Optional((.frac.1424: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> .frac.1424;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> 0.0;
      }), 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/num/ddouble/ddouble.1(seconds);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/num/ddouble/(+)((std/num/ddouble/ddouble.1(seconds)), (std/num/ddouble/Ddouble((match (frac) {
              ((std/core/types/Optional((.frac.14240: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/double>))
                 -> .frac.14240;
              ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/double>))
                 -> 0.0;
            }), 0.0)));
    };
  };
fun timespan.1 // inline size: 1
  = fn(secs: std/core/types/double){
    std/num/ddouble/ddouble(secs);
  };
inline fun timespan.2 // inline size: 0
  = fn(secs: std/num/ddouble/ddouble){
    secs;
  };
fun days-seconds // inline size: 8
  = fn(ts: timestamp){
    val secs : std/num/ddouble/ddouble
      = std/num/ddouble/floor((match (ts) {
        ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
           -> .x;
      }));
    val frac : std/num/ddouble/ddouble
      = std/num/ddouble/(+)((match (ts) {
          ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.pat10: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x0: timespan) : timespan, (.pat20: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
             -> .x0;
        }), (std/num/ddouble/(~)(secs)));
    match ((std/core/divmod((std/num/ddouble/int(secs, (std/core/types/None<std/core/types/int>))), 86400))) {
      ((.skip std/core/types/(,)((days: std/core/types/int) : std/core/types/int, (dsecs: std/core/types/int) : std/core/types/int) : (std/core/types/int, std/core/types/int) ) as .pat4: (std/core/types/int, std/core/types/int))
         -> std/core/types/(,)<std/core/types/int,std/num/ddouble/ddouble>(days, (std/num/ddouble/(+)((std/num/ddouble/ddouble.1(dsecs)), frac)));
    };
  };
fun days // inline size: 1
  = fn(ts: timestamp){
    val .this.3806 : (std/core/types/int, std/num/ddouble/ddouble)
          = std/time/timestamp/days-seconds(ts);
    match (.this.3806) {
      ((.skip std/core/types/(,)((.x: std/core/types/int) : std/core/types/int, (.pat0: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/int, std/num/ddouble/ddouble) ) as .pat: (std/core/types/int, std/num/ddouble/ddouble))
         -> .x;
    };
  };
fun days-clock // inline size: 4
  = fn(ts: timestamp){
    match ((std/time/timestamp/days-seconds(ts))) {
      ((.skip std/core/types/(,)((days: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as secs: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/int, std/num/ddouble/ddouble) ) as .pat: (std/core/types/int, std/num/ddouble/ddouble))
         -> std/core/types/(,)<std/core/types/int,std/time/date/clock>(days, (std/time/date/clock.3(secs, (std/time/timestamp/leap(ts)))));
    };
  };
fun max // inline size: 2
  = fn(i: timestamp, j: timestamp){
    match ((std/time/timestamp/(>=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun min // inline size: 2
  = fn(i: timestamp, j: timestamp){
    match ((std/time/timestamp/(<=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun round-to-prec // inline size: 10
  = fn(t: timestamp, prec: std/core/types/int){
    std/time/timestamp/Timestamp((match ((std/core/(<=.1)(prec, 0))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
           -> std/num/ddouble/round((match (t) {
            ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.pat10: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat20: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
               -> .x;
          }));
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
           -> (match ((std/core/(>.1)(prec, 31))) {
            ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
               -> (match (t) {
                ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.pat10: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat20: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
                   -> .x;
              });
            ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
               -> val p : std/num/ddouble/ddouble
                        = std/num/ddouble/powi10(prec);
              std/num/ddouble/(/)((std/num/ddouble/round((std/num/ddouble/(*)((match (t) {
                    ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.pat10: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat20: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat3: timestamp)
                       -> .x;
                  }), p)))), p);
          });
      }), (match (t) {
        ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat11: std/core/types/double) : std/core/types/double, (.pat21: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat01: timespan) : timespan, (.x0: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat4: timestamp)
           -> .x0;
      }));
  };
fun seconds-into-day // inline size: 4
  = fn(ts: timestamp){
    std/num/ddouble/(+)(val .this.3811 : (std/core/types/int, std/num/ddouble/ddouble)
                              = (std/time/timestamp/days-seconds(ts));
      (match (.this.3811) {
        ((.skip std/core/types/(,)((.pat0: std/core/types/int) : std/core/types/int, (.x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/int, std/num/ddouble/ddouble) ) as .pat: (std/core/types/int, std/num/ddouble/ddouble))
           -> .x;
      }), val i.3812 : std/core/types/int
                = (std/time/timestamp/leap(ts));
      (std/num/ddouble/ddouble-int-exp(i.3812, 0)));
  };
fun unsafe-timespan-withleap // inline size: 10
  = fn(ts: timestamp){
    std/num/ddouble/(+)((match (ts) {
        ((.skip std/time/timestamp/Timestamp(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: timespan) : timespan, (.pat2: std/core/types/int32) : std/core/types/int32) : timestamp ) as .pat: timestamp)
           -> .x;
      }), val seconds.3832 : std/core/types/int
                = (std/time/timestamp/leap(ts));
      (match ((std/core/(==.2)((match ((std/core/types/None<std/core/types/double>)) {
          ((std/core/types/Optional((.frac.1424: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/double>))
             -> .frac.1424;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/double>))
             -> 0.0;
        }), 0.0))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat10: std/core/types/bool)
           -> std/num/ddouble/ddouble.1(seconds.3832);
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat20: std/core/types/bool)
           -> std/num/ddouble/(+)((std/num/ddouble/ddouble.1(seconds.3832)), (std/num/ddouble/Ddouble((match ((std/core/types/None<std/core/types/double>)) {
                ((std/core/types/Optional((.frac.14240: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/double>))
                   -> .frac.14240;
                ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat01: ((std/core/types/optional :: V -> V)<std/core/types/double>))
                   -> 0.0;
              }), 0.0)));
      }));
  };