/* Date, clock, and week days support.

   Defines basic types for human readable time. Years, months, days etc. are always 1-based.
   Week dates are absent as they are treated as normal dates, using the `std/time/calendars/cal-iso-week` calendar.
*/
module interface std/time/date
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core = std/core = "";
private import std/num/double = std/num/double = "";
private import std/num/ddouble = std/num/ddouble = "";
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// A clock consists of the hour, minute, second, and fractional second (between ``0.0` and `1.0`).
public type clock {
  // A clock consists of the hour, minute, second, and fractional second (between ``0.0` and `1.0`).
  public con Clock(hours: std/core/types/int, minutes: std/core/types/int, seconds: std/num/ddouble/ddouble) : (hours : std/core/types/int, minutes : std/core/types/int, seconds : std/num/ddouble/ddouble) -> clock;
};
// A date consists of a the year, month, and day.
public value{0,3} type date {
  // A date consists of a the year, month, and day.
  public con Date(year: std/core/types/int, month: std/core/types/int, day: std/core/types/int) : (year : std/core/types/int, month : std/core/types/int, day : std/core/types/int) -> date;
};
// An ISO day of the week, starting at Monday (=1) up to Sunday (=7).
public value{1,0} type weekday {
  public con Mon : weekday;
  public con Tue : weekday;
  public con Wed : weekday;
  public con Thu : weekday;
  public con Fri : weekday;
  public con Sat : weekday;
  public con Sun : weekday;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `hours` constructor field of the `:clock` type.
public fun hours : (clock : clock) -> std/core/types/int;
// Automatically generated. Retrieves the `minutes` constructor field of the `:clock` type.
public fun minutes : (clock : clock) -> std/core/types/int;
// Automatically generated. Retrieves the `seconds` constructor field of the `:clock` type.
public fun seconds : (clock : clock) -> std/num/ddouble/ddouble;
public fun .copy : (clock, hours : (std/core/types/optional :: V -> V)<std/core/types/int>, minutes : (std/core/types/optional :: V -> V)<std/core/types/int>, seconds : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>) -> clock;
// Automatically generated. Retrieves the `year` constructor field of the `:date` type.
public fun year : (date : date) -> std/core/types/int;
// Automatically generated. Retrieves the `month` constructor field of the `:date` type.
public fun month : (date : date) -> std/core/types/int;
// Automatically generated. Retrieves the `day` constructor field of the `:date` type.
public fun day : (date : date) -> std/core/types/int;
public fun .copy.1 : (date, year : (std/core/types/optional :: V -> V)<std/core/types/int>, month : (std/core/types/optional :: V -> V)<std/core/types/int>, day : (std/core/types/optional :: V -> V)<std/core/types/int>) -> date;
// Automatically generated. Tests for the `Mon` constructor of the `:weekday` type.
public fun is-mon : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Tue` constructor of the `:weekday` type.
public fun is-tue : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Wed` constructor of the `:weekday` type.
public fun is-wed : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Thu` constructor of the `:weekday` type.
public fun is-thu : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Fri` constructor of the `:weekday` type.
public fun is-fri : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Sat` constructor of the `:weekday` type.
public fun is-sat : (weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Sun` constructor of the `:weekday` type.
public fun is-sun : (weekday : weekday) -> std/core/types/bool;
// Convert a `:weekday` to an `:int` using the ISO definition which starts at Monday as 1,
// up to Sunday as 7.
public fun int : (wd : weekday) -> std/core/types/int;
// Add two dates field-wise together.
public fun (+) : (d1 : date, d2 : date) -> date;
// Add two clock together.
public fun (+.1) : (c : clock, d : clock) -> clock;
// Convert a weekday number to a `:weekday`(starting at Monday (=1) up to Sunday (=7)).
// Takes the integer `i - 1` modulo 7, so `0` or `14` also become Sunday etc.
public fun weekday : (i : std/core/types/int) -> weekday;
// Return the `:weekday` that comes `n` days after week day `wd`.
public fun (+.2) : (wd : weekday, n : std/core/types/int) -> weekday;
// Return the `:weekday` that comes `n` days before week day `wd`.
public fun (-) : (wd : weekday, n : std/core/types/int) -> weekday;
// Return the difference between two week days:\
// `wd2 == wd1 + (wd2 - wd1)`
public fun (-.1) : (wd1 : weekday, wd2 : weekday) -> std/core/types/int;
// Compare two dates by fields.
public fun compare : (d : date, e : date) -> std/core/types/order;
public fun (==) : (i : date, j : date) -> std/core/types/bool;
// Return the total seconds of a `:clock` assuming 60 seconds per
// minute and 60 minutes per hour.
public fun total-seconds : (c : clock) -> std/num/ddouble/ddouble;
// Compare two clocks as by their total seconds.
public fun compare.1 : (c : clock, d : clock) -> std/core/types/order;
public fun (==.1) : (i : clock, j : clock) -> std/core/types/bool;
// Compare weekdays.
public fun compare.2 : (wd1 : weekday, wd2 : weekday) -> std/core/types/order;
public fun (==.2) : (i : weekday, j : weekday) -> std/core/types/bool;
// Create a clock from a seconds as an `:int` with an optional fraction.
// Normalizes the clock with seconds and minutes under 60 but
// adds the fraction as is to the final seconds, so that might
// be `>= 60` if the fraction `>= 1.0`;
public fun clock.2 : (seconds : std/core/types/int, frac : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>) -> clock;
// Create a clock from seconds; normalizes the clock with seconds and minutes under 60.
public fun clock : (seconds : std/num/ddouble/ddouble) -> clock;
// Create a clock from a seconds as an `:int` with an optional fraction.
// Normalizes the clock with seconds and minutes under 60 but
// adds the fraction as is to the final seconds, so that might
// be `>= 60` if the fraction `>= 1.0`;
public fun clock.1 : (seconds : std/core/types/int, frac : std/core/types/double) -> clock;
public fun clock.3 : (seconds : std/num/ddouble/ddouble, leap : std/core/types/int) -> clock;
public fun (!=) : (i : date, j : date) -> std/core/types/bool;
public fun (!=.1) : (i : clock, j : clock) -> std/core/types/bool;
public fun (!=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
public fun (<) : (i : date, j : date) -> std/core/types/bool;
public fun (<.1) : (i : clock, j : clock) -> std/core/types/bool;
public fun (<.2) : (i : weekday, j : weekday) -> std/core/types/bool;
public fun (<=) : (i : date, j : date) -> std/core/types/bool;
public fun (<=.1) : (i : clock, j : clock) -> std/core/types/bool;
public fun (<=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
public fun (>) : (i : date, j : date) -> std/core/types/bool;
public fun (>.1) : (i : clock, j : clock) -> std/core/types/bool;
public fun (>.2) : (i : weekday, j : weekday) -> std/core/types/bool;
public fun (>=) : (i : date, j : date) -> std/core/types/bool;
public fun (>=.1) : (i : clock, j : clock) -> std/core/types/bool;
public fun (>=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
// The zero clock
public val clock0 : clock;
// Return the ISO calendar date of Easter in a given year (Algorithm by [J.M. Oudin](http://aa.usno.navy.mil/faq/docs/easter.php)).
public fun easter : (year : std/core/types/int) -> date;
// Is this a zero clock?
public fun is-zero : (c : clock) -> std/core/types/bool;
// Return the fraction of the seconds as milli-seconds (10^-3^).
public fun milli-seconds : (c : clock) -> std/core/types/int;
// Return the fraction of seconds as nano-seconds ((10^-9^).
public fun nano-seconds : (c : clock) -> std/core/types/int;
// Round a clock time to a certain number of digits precision (of the fraction of seconds) (default `9`, nano seconds).
public fun round-to-prec : (c : clock, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> clock;
// Show seconds
public fun show-seconds : (secs : std/num/ddouble/ddouble, max-prec : (std/core/types/optional :: V -> V)<std/core/types/int>, secs-width : (std/core/types/optional :: V -> V)<std/core/types/int>, unit : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// pad with zeros
private fun show0 : (i : std/core/types/int, width : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a year in ISO format (using 5+ digits and explicit sign for years < 0 or years > 9999)).
public fun show-year : (year : std/core/types/int) -> std/core/types/string;
// Show a date in ISO format. `Date(2000,1,1).show == "2000-01-01"`.
// Takes an optional `month-prefix` (=`""`) that is used by the ISO week
// and month calendar to add a `"W"` or `"M"` prefix respectively.
public fun show : (d : date, month-prefix : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a clock in ISO format up to an optional maximum precision (=`9`).\
// `Clock(23,30,fixed(1.123)).show == "23:30:01.123"`\
// `Clock(23,30,fixed(1.123)).show(0) == "23:30:01"`
public fun show.1 : (c : clock, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a `:weekday` as an English string (`Sun.show == "Sunday"`).
public fun show.2 : (wd : weekday) -> std/core/types/string;
// Show a `:weekday` as a 3 letter English string (`Sun.show-short == "Sun"`)
public fun show-short : (wd : weekday) -> std/core/types/string;
// Create an ISO weekdate where the "month" is the ISO week number.
public fun weekdate : (year : std/core/types/int, month : std/core/types/int, weekday : weekday) -> date;
// Return the whole seconds part of a `:clock`.
public fun whole-seconds : (c : clock) -> std/core/types/int;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline fun hours // inline size: 0
  = fn(clock: clock){
    match (clock) {
      ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
inline fun minutes // inline size: 0
  = fn(clock: clock){
    match (clock) {
      ((.skip std/time/date/Clock((.pat0: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
inline fun seconds // inline size: 0
  = fn(clock: clock){
    match (clock) {
      ((.skip std/time/date/Clock((.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
fun .copy // inline size: 4
  = fn(.this: clock, hours: (std/core/types/optional :: V -> V)<std/core/types/int>, minutes: (std/core/types/optional :: V -> V)<std/core/types/int>, seconds: (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>){
    std/time/date/Clock((match (hours) {
        ((std/core/types/Optional((.hours.97: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .hours.97;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat1: clock)
               -> .x;
          });
      }), (match (minutes) {
        ((std/core/types/Optional((.minutes.103: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .minutes.103;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat20: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/double) : std/core/types/double, (.pat30: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat12: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
               -> .x0;
          });
      }), (match (seconds) {
        ((std/core/types/Optional((.seconds.109: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat31: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
           -> .seconds.109;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat40: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.pat02: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat22: std/core/types/double) : std/core/types/double, (.pat32: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
               -> .x1;
          });
      }));
  };
inline fun year // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
inline fun month // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.pat0: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
inline fun day // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
fun .copy.1 // inline size: 4
  = fn(.this: date, year: (std/core/types/optional :: V -> V)<std/core/types/int>, month: (std/core/types/optional :: V -> V)<std/core/types/int>, day: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/time/date/Date((match (year) {
        ((std/core/types/Optional((.year.143: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .year.143;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int) : date ) as .pat1: date)
               -> .x;
          });
      }), (match (month) {
        ((std/core/types/Optional((.month.149: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .month.149;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.pat01: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, (.pat12: std/core/types/int) : std/core/types/int) : date ) as .pat3: date)
               -> .x0;
          });
      }), (match (day) {
        ((std/core/types/Optional((.day.155: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat30: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .day.155;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.pat02: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int) : date ) as .pat5: date)
               -> .x1;
          });
      }));
  };
fun is-mon // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Mon() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-tue // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Tue() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-wed // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Wed() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-thu // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Thu() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-fri // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Fri() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-sat // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Sat() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun is-sun // inline size: 1
  = fn(weekday: weekday){
    match (weekday) {
      ((std/time/date/Sun() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun int // inline size: 6
  = fn(wd: weekday){
    match (wd) {
      ((std/time/date/Mon() : weekday ) as .pat: weekday)
         -> 1;
      ((std/time/date/Tue() : weekday ) as .pat0: weekday)
         -> 2;
      ((std/time/date/Wed() : weekday ) as .pat1: weekday)
         -> 3;
      ((std/time/date/Thu() : weekday ) as .pat2: weekday)
         -> 4;
      ((std/time/date/Fri() : weekday ) as .pat3: weekday)
         -> 5;
      ((std/time/date/Sat() : weekday ) as .pat4: weekday)
         -> 6;
      ((.skip std/time/date/Sun() : weekday ) as .pat5: weekday)
         -> 7;
    };
  };
fun (+) // inline size: 4
  = fn(d1: date, d2: date){
    std/time/date/Date((std/core/(+)((match (d1) {
          ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
             -> .x;
        }), (match (d2) {
          ((.skip std/time/date/Date((.x0: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int) : date ) as .pat2: date)
             -> .x0;
        }))), (std/core/(+)((match (d1) {
          ((.skip std/time/date/Date((.pat01: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int) : date ) as .pat3: date)
             -> .x1;
        }), (match (d2) {
          ((.skip std/time/date/Date((.pat02: std/core/types/int) : std/core/types/int, (.x2: std/core/types/int) : std/core/types/int, (.pat12: std/core/types/int) : std/core/types/int) : date ) as .pat4: date)
             -> .x2;
        }))), (std/core/(+)((match (d1) {
          ((.skip std/time/date/Date((.pat03: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, (.x3: std/core/types/int) : std/core/types/int) : date ) as .pat5: date)
             -> .x3;
        }), (match (d2) {
          ((.skip std/time/date/Date((.pat04: std/core/types/int) : std/core/types/int, (.pat14: std/core/types/int) : std/core/types/int, (.x4: std/core/types/int) : std/core/types/int) : date ) as .pat6: date)
             -> .x4;
        }))));
  };
fun (+.1) // inline size: 4
  = fn(c: clock, d: clock){
    std/time/date/Clock((std/core/(+)((match (c) {
          ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
             -> .x;
        }), (match (d) {
          ((.skip std/time/date/Clock((.x0: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat30: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
             -> .x0;
        }))), (std/core/(+)((match (c) {
          ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/double) : std/core/types/double, (.pat31: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat11: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
             -> .x1;
        }), (match (d) {
          ((.skip std/time/date/Clock((.pat02: std/core/types/int) : std/core/types/int, (.x2: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat22: std/core/types/double) : std/core/types/double, (.pat32: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat12: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat6: clock)
             -> .x2;
        }))), (std/num/ddouble/(+)((match (c) {
          ((.skip std/time/date/Clock((.pat03: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat23: std/core/types/double) : std/core/types/double, (.pat33: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x3: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat7: clock)
             -> .x3;
        }), (match (d) {
          ((.skip std/time/date/Clock((.pat04: std/core/types/int) : std/core/types/int, (.pat14: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat24: std/core/types/double) : std/core/types/double, (.pat34: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x4: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat8: clock)
             -> .x4;
        }))));
  };
fun (-.1) // inline size: 4
  = fn(wd1: weekday, wd2: weekday){
    std/core/(%)((std/core/(-)((std/time/date/int(wd1)), (std/time/date/int(wd2)))), 7);
  };
fun compare // inline size: 5
  = fn(d: date, e: date){
    match ((std/core/compare((match (d) {
        ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
           -> .x;
      }), (match (e) {
        ((.skip std/time/date/Date((.x0: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int) : date ) as .pat2: date)
           -> .x0;
      })))) {
      ((std/core/types/Eq() : std/core/types/order ) as .pat3: std/core/types/order)
         -> (match ((std/core/compare((match (d) {
            ((.skip std/time/date/Date((.pat01: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int) : date ) as .pat4: date)
               -> .x1;
          }), (match (e) {
            ((.skip std/time/date/Date((.pat02: std/core/types/int) : std/core/types/int, (.x2: std/core/types/int) : std/core/types/int, (.pat12: std/core/types/int) : std/core/types/int) : date ) as .pat5: date)
               -> .x2;
          })))) {
          ((std/core/types/Eq() : std/core/types/order ) as .pat03: std/core/types/order)
             -> std/core/compare((match (d) {
                ((.skip std/time/date/Date((.pat04: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, (.x3: std/core/types/int) : std/core/types/int) : date ) as .pat6: date)
                   -> .x3;
              }), (match (e) {
                ((.skip std/time/date/Date((.pat05: std/core/types/int) : std/core/types/int, (.pat14: std/core/types/int) : std/core/types/int, (.x4: std/core/types/int) : std/core/types/int) : date ) as .pat7: date)
                   -> .x4;
              }));
          (ord: std/core/types/order)
             -> ord;
        });
      (ord0: std/core/types/order)
         -> ord0;
    };
  };
fun (==) // inline size: 6
  = fn(i: date, j: date){
    val x.9720 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.9720)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun total-seconds // inline size: 5
  = fn(c: clock){
    std/num/ddouble/(+)(val i.9722 : std/core/types/int
                              = (std/core/(*)((std/core/(+)((std/core/(*)((match (c) {
                                      ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
                                         -> .x;
                                    }), 60)), (match (c) {
                                    ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat30: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
                                       -> .x0;
                                  }))), 60));
      (std/num/ddouble/ddouble-int-exp(i.9722, 0)), (match (c) {
        ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/double) : std/core/types/double, (.pat31: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
           -> .x1;
      }));
  };
fun (==.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9728 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(==.1)((std/core/int.5(x.9728)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun compare.2 // inline size: 3
  = fn(wd1: weekday, wd2: weekday){
    std/core/compare((std/time/date/int(wd1)), (std/time/date/int(wd2)));
  };
fun (==.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9730 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(==.1)((std/core/int.5(x.9730)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun clock.2 // inline size: 7
  = fn(seconds: std/core/types/int, frac: (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>){
    match ((std/core/divmod(seconds, 60))) {
      ((.skip std/core/types/(,)((hm: std/core/types/int) : std/core/types/int, (s: std/core/types/int) : std/core/types/int) : (std/core/types/int, std/core/types/int) ) as .pat1: (std/core/types/int, std/core/types/int))
         -> (match ((std/core/divmod(hm, 60))) {
          ((.skip std/core/types/(,)((h: std/core/types/int) : std/core/types/int, (m: std/core/types/int) : std/core/types/int) : (std/core/types/int, std/core/types/int) ) as .pat2: (std/core/types/int, std/core/types/int))
             -> std/time/date/Clock(h, m, (std/num/ddouble/(+)((std/num/ddouble/ddouble.1(s)), (match (frac) {
                  ((std/core/types/Optional((.frac.1700: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
                     -> .frac.1700;
                  ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat0: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
                     -> std/num/ddouble/Ddouble(0.0, 0.0);
                }))));
        });
    };
  };
fun clock.1 // inline size: 9
  = fn(seconds: std/core/types/int, frac: std/core/types/double){
    val frac0.9735 : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>
          = std/core/types/Optional<std/num/ddouble/ddouble>((std/num/ddouble/ddouble(frac)));
    match ((std/core/divmod(seconds, 60))) {
      ((.skip std/core/types/(,)((hm: std/core/types/int) : std/core/types/int, (s: std/core/types/int) : std/core/types/int) : (std/core/types/int, std/core/types/int) ) as .pat1: (std/core/types/int, std/core/types/int))
         -> (match ((std/core/divmod(hm, 60))) {
          ((.skip std/core/types/(,)((h: std/core/types/int) : std/core/types/int, (m: std/core/types/int) : std/core/types/int) : (std/core/types/int, std/core/types/int) ) as .pat2: (std/core/types/int, std/core/types/int))
             -> std/time/date/Clock(h, m, (std/num/ddouble/(+)((std/num/ddouble/ddouble.1(s)), (match (frac0.9735) {
                  ((std/core/types/Optional((.frac.1700: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
                     -> .frac.1700;
                  ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat0: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
                     -> std/num/ddouble/Ddouble(0.0, 0.0);
                }))));
        });
    };
  };
fun (!=) // inline size: 6
  = fn(i: date, j: date){
    val x.9738 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.9738)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (!=.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9740 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(!=.1)((std/core/int.5(x.9740)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (!=.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9742 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(!=.1)((std/core/int.5(x.9742)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<) // inline size: 6
  = fn(i: date, j: date){
    val x.9744 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.9744)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9746 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(==.1)((std/core/int.5(x.9746)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9748 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(==.1)((std/core/int.5(x.9748)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<=) // inline size: 6
  = fn(i: date, j: date){
    val x.9750 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.9750)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<=.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9752 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(!=.1)((std/core/int.5(x.9752)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<=.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9754 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(!=.1)((std/core/int.5(x.9754)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>) // inline size: 6
  = fn(i: date, j: date){
    val x.9756 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(==.1)((std/core/int.5(x.9756)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9758 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(==.1)((std/core/int.5(x.9758)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9760 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(==.1)((std/core/int.5(x.9760)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>=) // inline size: 6
  = fn(i: date, j: date){
    val x.9762 : std/core/types/order
          = std/time/date/compare(i, j);
    std/core/(!=.1)((std/core/int.5(x.9762)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>=.1) // inline size: 6
  = fn(i: clock, j: clock){
    val x.9764 : std/core/types/order
          = std/time/date/compare.1(i, j);
    std/core/(!=.1)((std/core/int.5(x.9764)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>=.2) // inline size: 6
  = fn(i: weekday, j: weekday){
    val x.9766 : std/core/types/order
          = std/time/date/compare.2(i, j);
    std/core/(!=.1)((std/core/int.5(x.9766)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun is-zero // inline size: 5
  = fn(c: clock){
    match ((std/core/is-zero((match (c) {
      ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat4: std/core/types/bool)
         -> (match ((std/core/is-zero((match (c) {
          ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat30: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
             -> .x0;
        })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat01: std/core/types/bool)
             -> std/core/(==.2)((match ((match (c) {
                ((.skip std/time/date/Clock((.pat03: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/double) : std/core/types/double, (.pat31: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x2: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat7: clock)
                   -> .x2;
              })) {
                ((.skip std/num/ddouble/Ddouble((.x1: std/core/types/double) : std/core/types/double, (.pat02: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat6: std/num/ddouble/ddouble)
                   -> .x1;
              }), 0.0);
          (.pat12: std/core/types/bool)
             -> std/core/types/False;
        });
      (.pat22: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun milli-seconds // inline size: 9
  = fn(c: clock){
    std/core/int.3(val d.9772 : std/core/types/double
                         = (std/core/(*.1)(val x.9773 : std/num/ddouble/ddouble
                                                 = val y.21009 : std/num/ddouble/ddouble
                                                         = (std/num/ddouble/truncate((match (c) {
                                                           ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x0: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat2: clock)
                                                              -> .x0;
                                                         })));
                                                 (std/num/ddouble/(+)((match (c) {
                                                     ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x0: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat2: clock)
                                                        -> .x0;
                                                   }), (std/num/ddouble/(~)(y.21009))));
                           (match (x.9773) {
                             ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble)
                                -> .x;
                           }), 1000.0));
    (match ((std/core/(>=.2)(d.9772, 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/double/floor(d.9772);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/num/double/ceiling(d.9772);
    }));
  };
fun nano-seconds // inline size: 9
  = fn(c: clock){
    std/core/int.3(val d.9776 : std/core/types/double
                         = (std/core/(*.1)(val x.9777 : std/num/ddouble/ddouble
                                                 = val y.21009 : std/num/ddouble/ddouble
                                                         = (std/num/ddouble/truncate((match (c) {
                                                           ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x0: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat2: clock)
                                                              -> .x0;
                                                         })));
                                                 (std/num/ddouble/(+)((match (c) {
                                                     ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x0: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat2: clock)
                                                        -> .x0;
                                                   }), (std/num/ddouble/(~)(y.21009))));
                           (match (x.9777) {
                             ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble)
                                -> .x;
                           }), 1.0e9));
    (match ((std/core/(>=.2)(d.9776, 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/double/floor(d.9776);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/num/double/ceiling(d.9776);
    }));
  };
fun show.2 // inline size: 6
  = fn(wd: weekday){
    match (wd) {
      ((std/time/date/Mon() : weekday ) as .pat: weekday)
         -> "Monday";
      ((std/time/date/Tue() : weekday ) as .pat0: weekday)
         -> "Tuesday";
      ((std/time/date/Wed() : weekday ) as .pat1: weekday)
         -> "Wednesday";
      ((std/time/date/Thu() : weekday ) as .pat2: weekday)
         -> "Thursday";
      ((std/time/date/Fri() : weekday ) as .pat3: weekday)
         -> "Friday";
      ((std/time/date/Sat() : weekday ) as .pat4: weekday)
         -> "Saturday";
      ((.skip std/time/date/Sun() : weekday ) as .pat5: weekday)
         -> "Sunday";
    };
  };
fun show-short // inline size: 10
  = fn(wd: weekday){
    std/core/string.3(val s.9830 : std/core/types/string
                        = (std/time/date/show.2(wd));
                      val n.9831 : ((std/core/types/optional :: V -> V)<std/core/types/int>)
                        = (std/core/types/Optional<std/core/types/int>(3));
                      val slice : std/core/sslice
                        = (std/core/first1(s.9830));
    (match ((std/core/(==.1)((match (n.9831) {
        ((std/core/types/Optional((.n.12425: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .n.12425;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 1;
      }), 1))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> slice;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/core/extend(slice, (std/core/(-)((match (n.9831) {
              ((std/core/types/Optional((.n.124250: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/int>))
                 -> .n.124250;
              ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/int>))
                 -> 1;
            }), 1)));
    }));
  };
fun weekdate // inline size: 2
  = fn(year: std/core/types/int, month: std/core/types/int, weekday: weekday){
    std/time/date/Date(year, month, (std/time/date/int(weekday)));
  };
fun whole-seconds // inline size: 5
  = fn(c: clock){
    std/num/ddouble/int((match ((std/num/ddouble/is-neg((match (c) {
        ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat1: clock)
           -> .x;
      })))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
           -> std/num/ddouble/ceiling((match (c) {
            ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat1: clock)
               -> .x;
          }));
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
           -> std/num/ddouble/floor((match (c) {
            ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : std/num/ddouble/ddouble ) as .x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat1: clock)
               -> .x;
          }));
      }), (std/core/types/None<std/core/types/int>));
  };