module interface model-resources
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core/hnd = std/core/hnd = "";
private import std/core = std/core = "";
private import std/num/double = std/num/double = "";
private import std/num/random = std/num/random = "";
private import effects-and-types = effects-and-types = "";
private import handlers = handlers = "";
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
local alias effects-and-types/data_1d = (std/core/list :: V -> V)<std/core/types/double> = 1;
local alias effects-and-types/model<a,(e :: E)> :: (V, E) -> V = () -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>|(e :: E)> a = 1;
local alias effects-and-types/nmodel<a> :: V -> V = () -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> a = 1;
local alias effects-and-types/regression = ((effects-and-types/nmodel :: V -> V)<(std/core/types/double) -> std/core/types/double> == 1 () -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ((std/core/types/double) -> std/core/types/double)) = 2;
local alias effects-and-types/two_d_data = (std/core/list :: V -> V)<(std/core/types/double, std/core/types/double)> = 1;
local alias std/core/hnd/ev-index = std/core/types/size_t = 1;
// Stateful funs can manipulate heap `:h` using allocations, reads and writes.
local alias std/core/types/st<(h :: H)> :: H -> E = <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/types/alloc :: H -> X)<(h :: H)>> = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// monadic lift
private fun .mlift3168-bernoulli : (p : std/core/types/double, g : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/bool;
public fun bernoulli : (p : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/bool;
public fun box-muller : (u1 : std/core/types/double, u2 : std/core/types/double) -> std/core/types/double;
public val dataset : effects-and-types/two_d_data;
public fun square : (x : std/core/types/double) -> std/core/types/double;
public val gaussian_dataset : effects-and-types/data_1d;
public val gaussian_five : effects-and-types/data_1d;
public fun normal_pdf : (mean : std/core/types/double, sdv : std/core/types/double, x : std/core/types/double) -> effects-and-types/exp;
// monadic lift
private fun .mlift3169-fit : (f : (std/core/types/double) -> std/core/types/double, wild_ : (std/core/list :: V -> V)<()>) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> ((std/core/types/double) -> std/core/types/double);
// monadic lift
private fun .mlift3170-fit : (dataset : effects-and-types/two_d_data, f : (std/core/types/double) -> std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ((std/core/types/double) -> std/core/types/double);
public fun fit : (model : effects-and-types/regression, dataset : effects-and-types/two_d_data) -> effects-and-types/regression;
// monadic lift
private fun .mlift3171-fit_1d_gaussian : (f : std/core/types/double, wild_ : (std/core/list :: V -> V)<()>) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3172-fit_1d_gaussian : (dataset : effects-and-types/data_1d, f : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> std/core/types/double;
public fun fit_1d_gaussian : (model : (effects-and-types/nmodel :: V -> V)<std/core/types/double>, dataset : effects-and-types/data_1d) -> (effects-and-types/nmodel :: V -> V)<std/core/types/double>;
public fun gamma : forall<(h :: H)> (std/core/types/double) -> <(std/core/types/st :: H -> E)<(h :: H)>,(std/core/types/div :: E)> std/core/types/double;
// monadic lift
private fun .mlift3173-standard-normal : (std/core/types/double, std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3174-standard-normal : (std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
public fun standard-normal : () -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3175-normal : (mean : std/core/types/double, sdv : std/core/types/double, std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
public fun normal : (mean : std/core/types/double, sdv : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
public fun gaussian_model : () -> (effects-and-types/nmodel :: V -> V)<std/core/types/double>;
// monadic lift
private fun .mlift3176-generate_synthetic_lr_data : (std/core/types/double, std/core/types/bool) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> (std/core/types/double, std/core/types/bool);
// monadic lift
private fun .mlift3177-generate_synthetic_lr_data : (std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> (std/core/types/double, std/core/types/bool);
public fun generate_synthetic_lr_data : (num : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> (std/core/list :: V -> V)<(std/core/types/double, std/core/types/bool)>;
// monadic lift
private fun .mlift3178-grandx : (c : std/core/types/double, d : std/core/types/double, w : std/core/types/double, z : std/core/types/double, std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3179-grandx : (c : std/core/types/double, d : std/core/types/double, z : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
private fun grandx : (d : std/core/types/double, c : std/core/types/double, v : std/core/types/double) -> <(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3180-grand : (alpha : std/core/types/double, x : std/core/types/double, std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3181-grand : (alpha : std/core/types/double, x : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/div :: X)> std/core/types/double;
// monadic lift
private fun .mlift3182-grand : (beta : std/core/types/double, d : std/core/types/double, v : std/core/types/double) -> <(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
public fun grand : (alpha : std/core/types/double, beta : std/core/types/double) -> <(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3183-logistic_regression : (label : std/core/types/bool, p : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> ();
// monadic lift
private fun .mlift3184-logistic_regression : (b : std/core/types/double, m : std/core/types/double, wild_ : (std/core/list :: V -> V)<()>) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/div :: E)> (std/core/types/double, std/core/types/double);
// monadic lift
private fun .mlift3185-logistic_regression : (b : std/core/types/double, dat : (std/core/list :: V -> V)<(std/core/types/double, std/core/types/bool)>, m : std/core/types/double, sigma : std/core/types/double) -> <(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (std/core/types/double, std/core/types/double);
// monadic lift
private fun .mlift3186-logistic_regression : (dat : (std/core/list :: V -> V)<(std/core/types/double, std/core/types/bool)>, m : std/core/types/double, b : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (std/core/types/double, std/core/types/double);
// monadic lift
private fun .mlift3187-logistic_regression : (dat : (std/core/list :: V -> V)<(std/core/types/double, std/core/types/bool)>, m : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (std/core/types/double, std/core/types/double);
public fun logistic_regression : (dat : (std/core/list :: V -> V)<(std/core/types/double, std/core/types/bool)>) -> (effects-and-types/model :: (V, E) -> V)<(std/core/types/double, std/core/types/double),<(std/core/types/div :: E)>>;
public fun params : () -> (() -> <(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> std/core/types/double);
// monadic lift
private fun .mlift3188-op : (obs : (x : std/core/types/double, y : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (), s : std/core/types/double, x : std/core/types/double, x' : std/core/types/double, xs : (std/core/list :: V -> V)<std/core/types/double>, ys : (std/core/list :: V -> V)<std/core/types/double>, wild_ : ()) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> (std/core/list :: V -> V)<std/core/types/double>;
// monadic lift
private fun .mlift3189-op : (obs : (x : std/core/types/double, y : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (), s : std/core/types/double, x : std/core/types/double, xs : (std/core/list :: V -> V)<std/core/types/double>, y : std/core/types/double, ys : (std/core/list :: V -> V)<std/core/types/double>, x' : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (std/core/list :: V -> V)<std/core/types/double>;
// lift
private fun .lift3144-random_walk : (obs : (x : std/core/types/double, y : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> (), s : std/core/types/double, xss : (std/core/list :: V -> V)<std/core/types/double>, yss : (std/core/list :: V -> V)<std/core/types/double>) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> (std/core/list :: V -> V)<std/core/types/double>;
// monadic lift
private fun .mlift3190-random_walk : (x : std/core/types/double, y : std/core/types/double, std/core/hnd/ev-index) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> ();
// monadic lift
private fun .mlift3191-random_walk : ((std/core/list :: V -> V)<std/core/types/double>) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>> (std/core/list :: V -> V)<std/core/types/double>;
public fun random_walk : (zs : (std/core/list :: V -> V)<std/core/types/double>) -> ((s : std/core/types/double) -> (effects-and-types/nmodel :: V -> V)<(std/core/list :: V -> V)<std/core/types/double>>);
// monadic lift
private fun .mlift3192-sequential_gaussian : forall<(h :: H)> (x : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/double>, std/core/hnd/ev-index) -> <(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>> std/core/types/double;
// monadic lift
private fun .mlift3193-sequential_gaussian : forall<(h :: H)> (data_point : std/core/types/double, std/core/types/double) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ();
// monadic lift
private fun .mlift3194-sequential_gaussian : forall<(h :: H)> (data_point : std/core/types/double, x : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/double>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ();
// monadic lift
private fun .mlift3195-sequential_gaussian : forall<(h :: H)> (data_point : std/core/types/double, x : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/double>, std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ();
// monadic lift
private fun .mlift3196-sequential_gaussian : forall<(h :: H)> (data_point : std/core/types/double, x : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/double>, std/core/types/double) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> ();
// monadic lift
private fun .mlift3197-sequential_gaussian : forall<(h :: H)> (x : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/double>, wild_0 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>,(std/core/types/handled :: HX -> X)<(effects-and-types/score :: HX)>,(std/core/types/handled :: HX -> X)<(std/num/random/random :: HX)>> std/core/types/double;
public fun sequential_gaussian : (data_point : std/core/types/double) -> (effects-and-types/nmodel :: V -> V)<std/core/types/double>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun bernoulli // inline size: 7
  = fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(p: std/core/types/double){
    val x.3198 : std/core/types/double
          = effects-and-types/sample();
    match ((std/core/hnd/yielding())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<std/core/types/double,std/core/types/bool,<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>((fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(g: std/core/types/double){
          (model-resources/.mlift3168-bernoulli(p, g));
        }));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(<.4)(x.3198, p))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/True;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/False;
        });
    };
  };
fun box-muller // inline size: 6
  = fn(u1: std/core/types/double, u2: std/core/types/double){
    std/core/(*.1)((std/num/double/sqrt((std/core/(*.1)(-2.0, (std/num/double/log(u1)))))), (std/num/double/cos((std/core/(*.1)(6.283185307179586, u2)))));
  };
fun square // inline size: 1
  = fn(x: std/core/types/double){
    std/core/(*.1)(x, x);
  };
fun standard-normal // inline size: 10
  = fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(){
    val x.3259 : std/core/types/double
          = effects-and-types/sample();
    match ((std/core/hnd/yielding())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<std/core/types/double,std/core/types/double,<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(model-resources/.mlift3174-standard-normal);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val x0.3263 : std/core/types/double
                  = effects-and-types/sample();
        (match ((std/core/hnd/yielding())) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/hnd/yield-extend<std/core/types/double,std/core/types/double,<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>((fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(.y.9: std/core/types/double){
              (model-resources/.mlift3173-standard-normal(x.3259, .y.9));
            }));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/hnd/.open-none2<std/core/types/double,std/core/types/double,std/core/types/double,(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(model-resources/box-muller, x.3259, x0.3263);
        });
    };
  };
fun normal // inline size: 7
  = fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(mean: std/core/types/double, sdv: std/core/types/double){
    val x.3267 : std/core/types/double
          = model-resources/standard-normal();
    match ((std/core/hnd/yielding())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<std/core/types/double,std/core/types/double,<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>((fn<<(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(.y.10: std/core/types/double){
          (model-resources/.mlift3175-normal(mean, sdv, .y.10));
        }));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/(+.3)(mean, (std/core/(*.1)(x.3267, sdv)));
    };
  };
fun params // inline size: 1
  = fn(){
    fn<<(std/core/types/div :: E),(std/core/types/handled :: HX -> X)<(effects-and-types/sample :: HX)>>>(){
      model-resources/grand(1.0, 1.0);
    };
  };