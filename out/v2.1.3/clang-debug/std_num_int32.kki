// 32-bit signed integers.
module interface std/num/int32
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core/hnd = std/core/hnd = "";
private import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for the empty effect.
local alias std/core/total :: E = (std/core/types/(<>) :: E) = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
public fun compare : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/order;
// Return the maximum of two integers
public fun max : (i : std/core/types/int32, j : std/core/types/int32) -> std/core/types/int32;
// The maximal integer value before overflow happens
public val max-int32 : std/core/types/int;
// Return the minimum of two integers
public fun min : (i : std/core/types/int32, j : std/core/types/int32) -> std/core/types/int32;
// Show an `:int32` in hexadecimal notation
// The `width`  parameter specifies how wide the hex value is where `'0'`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number (goes between the sign and the number).
public fun show-hex : (i : std/core/types/int32, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Convert an `:int32` to an `:int` but interpret the `:int32` as a 32-bit unsigned value.
public fun uint : (i : std/core/types/int32) -> std/core/types/int;
public fun sign : (i : std/core/types/int32) -> std/core/types/order;
public val one : std/core/types/int32;
public val zero : std/core/types/int32;
// Convert a boolean to an `:int32`.
public fun int32.1 : (b : std/core/types/bool) -> std/core/types/int32;
// Euclidean-0 modulus. See `(/):(x : int32, y : int32) -> int32` division for more information.
public fun (%) : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32;
/* 
Euclidean-0 division.
Euclidean division is defined as: For any `D`  and `d`  where `d!=0` , we have:

1. `D == d*(D/d) + (D%d)`
2. `D%d`  is always positive where `0 <= D%d < abs(d)`

Moreover, Euclidean-0 is a total function, for the case where `d==0`  we have
that `D%0 == D`  and `D/0 == 0` . So property (1) still holds, but not property (2).
Useful laws that hold for Euclidean-0 division:

* `D/(-d) == -(D/d)`
* `D%(-d) == D%d`
* `D/(2^n) == sar(D,n)         `  (with `0 <= n <= 31`)
* `D%(2^n) == D & ((2^n) - 1)  `  (with `0 <= n <= 31`)

Note that an interesting edge case is `min-int32 / -1` which equals `min-int32` since in modulo 32-bit
arithmetic `min-int32 == -1 * min-int32 == -1 * (min-int32 / -1) + (min-int32 % -1)` satisfying property (1).
Of course `(min-int32 + 1) / -1` is again positive (namely `max-int32`).

See also _Division and modulus for computer scientists, Daan Leijen, 2001_ 
[pdf](http://research.microsoft.com/pubs/151917/divmodnote.pdf) .
*/
public fun (/) : (x : std/core/types/int32, y : std/core/types/int32) -> std/core/types/int32;
// Negate an 32-bit integer
public fun (~) : (i : std/core/types/int32) -> (std/core/total :: E) std/core/types/int32;
// The minimal integer value before underflow happens
public val min-int32 : std/core/types/int;
// Negate a 32-bit integer
public fun negate : (i : std/core/types/int32) -> std/core/types/int32;
// Return the absolute value of an integer.
// Raises an exception if the `:int32` is `min-int32`
// (since the negation of `min-int32` equals itself and is still negative)
public fun abs : (i : std/core/types/int32) -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/int32;
// Return the absolute value of an integer.
// Returns 0 if the `:int32` is `min-int32`
// (since the negation of `min-int32` equals itself and is still negative)
public fun abs0 : (i : std/core/types/int32) -> std/core/types/int32;
// The number of bits in an `:int32` (always 32)
public val bits-int32 : std/core/types/int32;
// Convert an `:int32` to a boolean.
public fun bool : (i : std/core/types/int32) -> std/core/types/bool;
// Decrement a 32-bit integer.
public fun dec : (i : std/core/types/int32) -> std/core/types/int32;
// Increment a 32-bit integer.
public fun inc : (i : std/core/types/int32) -> std/core/types/int32;
public fun divmod : (x : std/core/types/int32, y : std/core/types/int32) -> (std/core/types/int32, std/core/types/int32);
public fun fold-int32 : forall<a> (start : std/core/types/int32, end : std/core/types/int32, init : a, f : (std/core/types/int32, a) -> a) -> a;
// Returns `true` if the integer `i`  is an even number.
public fun is-even : (i : std/core/types/int32) -> std/core/types/bool;
// Returns `true` if the integer `i`  is an odd number.
public fun is-odd : (i : std/core/types/int32) -> std/core/types/bool;
// Bitwise rotate an `:int32` `n` bits to the left.
// Does not rotate when `n` is negative.
public fun rotl : (i : std/core/types/int32, n : std/core/types/int32) -> std/core/types/int32;
// Bitwise rotate an `:int32` `n` bits to the right.
// Does not rotate when `n` is negative.
public fun rotr : (i : std/core/types/int32, n : std/core/types/int32) -> std/core/types/int32;
// Convert an `:int32` to a string
public fun show : (i : std/core/types/int32) -> std/core/types/string;
// Show an `:int32` in hexadecimal notation interpreted as an unsigned 32-bit value.
// The `width`  parameter specifies how wide the hex value is where `'0'`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number.
public fun show-hex32 : (i : std/core/types/int32, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Convert an `:int` to `:int32` but interpret the `int` as an unsigned 32-bit value.
// `i` is clamped between `0` and `0xFFFFFFFF`.\
// `0x7FFFFFFF.uint32 == 0x7FFFFFFF.int32 == max-int32`\
// `0x80000000.uint32 == -1.int32`\
// `0xFFFFFFFF.uint32 == -0x80000000.int32 == min-int32`\
public fun uint32 : (i : std/core/types/int) -> std/core/types/int32;
 
//------------------------------
//#kki: external declarations
 
// Convert a `:double` to an `:int32`. The double is clamped to the
// minimum or maximum `:int32` value if it is outside the range. A `nan` is
// mapped to `0`.
public extern int32 : (std/core/types/double) -> std/core/types/int32 {
  cs inline "Primitive.DoubleToInt32(#1)";
  js inline "$std_core._double_to_int32(#1)";
};
public extern (<=) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 <= #2)";
  js inline "(#1 <= #2)";
};
public extern (==) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
public extern (!=) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
public extern (>=) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 >= #2)";
  js inline "(#1 >= #2)";
};
public extern (<) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 < #2)";
  js inline "(#1 < #2)";
};
public extern (>) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 > #2)";
  js inline "(#1 > #2)";
};
public extern (+) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
};
public extern (-) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
};
public extern is-neg : (i : std/core/types/int32) -> std/core/types/bool = inline "(#1)<0";
public extern is-pos : (i : std/core/types/int32) -> std/core/types/bool = inline "0<=(#1)";
public extern is-zero : (i : std/core/types/int32) -> std/core/types/bool = inline "0==(#1)";
// Multiply two 32-bit integers.
public extern (*) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "#1*#2";
  js inline "$std_core._int32_multiply(#1,#2)";
};
// Take the bitwise _and_ of two `:int32`s
public extern and : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 & #2)";
// Take the bitwise _or_ of two `:int32`s
public extern or : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 | #2)";
// Take the bitwise _xor_ of two `:int32`s
public extern (^) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 ^ #2)";
// Bitwise _not_ of an `:int32`, i.e. flips all bits.
public extern not : (i : std/core/types/int32) -> std/core/types/int32 = inline "(~#1)";
// Shift an `:int32` `i` to the left by `n` bits.
// Returns `i` when `n` is negative, or `0` when `n >= bitsInt`.
public extern shl : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 = inline "(#1 << #2)";
// Logical shift an `:int32` to the right by `n` bits. Shift in zeros from the left.
// Returns `i` when `n` is negative, or `0` when `n >= bitsInt`.
public extern shr : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  c inline "((int32_t)((uint32_t)#1 >> #2))";
  cs inline "(Int32)(((UInt32)#1)>>#2)";
  js inline "(#1>>>#2)";
};
// Arithmetic shift an `:int32` to the right by `n` bits. Preserves the sign bit.
// Returns `i` when `n` is negative. When `n >= bitsInt` returns either `-1` when `i<0`, or `0` when `i>=0`.
public extern sar : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  c inline "(#1 >> #2)";
  cs inline "(#1>>#2)";
  js inline "(#1>>#2)";
};
// Truncated division (as in C). See also `(/):(x : int32, y : int32) -> int32`.
public extern cdiv : (std/core/types/int32, std/core/types/int32) -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/int32 {
  inline "(#1 / #2)";
  js inline "$std_core._int32_cdiv(#1,#2)";
};
// Truncated modulus (as in C). See also `(%):(x : int32, y : int32) -> int32`.
public extern cmod : (std/core/types/int32, std/core/types/int32) -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/int32 {
  inline "(#1 % #2)";
  js inline "$std_core._int32_cmod(#1,#2)";
};
// Truncated division (as in C). See also `(/):(x : int32, y : int32) -> int32`.
private extern unsafe-cdiv : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 / #2)";
  js inline "((#1/#2)|0)";
};
// Truncated modulus (as in C). See also `(%):(x : int32, y : int32) -> int32`.
private extern unsafe-cmod : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 % #2)";
  js inline "((#1 % #2)|0)";
};
// Convert an 32-bit integer to a double.
public extern double : (std/core/types/int32) -> std/core/types/double {
  c inline "((double)(#1))";
  cs inline "(double)(#1)";
  js inline "(#1)";
};
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun compare // inline size: 4
  = fn(x: std/core/types/int32, y: std/core/types/int32){
    match ((std/num/int32/(<)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/num/int32/(>)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun max // inline size: 2
  = fn(i: std/core/types/int32, j: std/core/types/int32){
    match ((std/num/int32/(>=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
inline val max-int32 // inline size: 0
  = 2147483647;
fun min // inline size: 2
  = fn(i: std/core/types/int32, j: std/core/types/int32){
    match ((std/num/int32/(<=)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun show-hex // inline size: 8
  = fn(i: std/core/types/int32, width: (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals: (std/core/types/optional :: V -> V)<std/core/types/bool>, pre: (std/core/types/optional :: V -> V)<std/core/types/string>){
    std/core/show-hex((std/core/int.1(i)), (std/core/types/Optional<std/core/types/int>((match (width) {
        ((std/core/types/Optional((.width.212: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .width.212;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 1;
      }))), (std/core/types/Optional<std/core/types/bool>((match (use-capitals) {
        ((std/core/types/Optional((.use-capitals.216: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .use-capitals.216;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/True;
      }))), (std/core/types/Optional<std/core/types/string>((match (pre) {
        ((std/core/types/Optional((.pre.220: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .pre.220;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "0x";
      }))));
  };
fun uint // inline size: 5
  = fn(i: std/core/types/int32){
    match ((std/num/int32/is-neg(i))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(+)(4294967296, (std/core/int.1(i)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/int.1(i);
    };
  };
fun sign // inline size: 4
  = fn(i: std/core/types/int32){
    match ((std/num/int32/is-pos(i))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Gt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/num/int32/is-neg(i))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Lt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
inline val one // inline size: 0
  = std/core/int32(1);
inline val zero // inline size: 0
  = std/core/int32(0);
fun int32.1 // inline size: 2
  = fn(b: std/core/types/bool){
    std/core/int32((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> 1;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> 0;
    }));
  };
fun (~) // inline size: 2
  = fn<(std/core/total :: E)>(i: std/core/types/int32){
    std/num/int32/(-)((std/core/int32(0)), i);
  };
inline val min-int32 // inline size: 0
  = std/core/(~)(2147483648);
fun negate // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(-)((std/core/int32(0)), i);
  };
fun abs0 // inline size: 9
  = fn(i: std/core/types/int32){
    match ((std/core/types/(!)((std/num/int32/is-neg(i))))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/num/int32/(>)(i, (std/core/int32((std/core/(~)(2147483648))))))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/num/int32/negate(i);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/int32(0);
        });
    };
  };
inline val bits-int32 // inline size: 0
  = std/core/int32(32);
fun bool // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(!=)(i, (std/core/int32(0)));
  };
fun dec // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(-)(i, (std/core/int32(1)));
  };
fun inc // inline size: 2
  = fn(i: std/core/types/int32){
    std/num/int32/(+)(i, (std/core/int32(1)));
  };
recursive fun fold-int32 // inline size: 5
  = forall<a> fn(start: std/core/types/int32, end: std/core/types/int32, init: a, f: (std/core/types/int32, a) -> a){
    (match ((std/num/int32/(>=)(start, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> init;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val x : a
                  = f(start, init);
        std/num/int32/fold-int32<a>((std/num/int32/inc(start)), end, x, f);
    });
  };
fun is-even // inline size: 4
  = fn(i: std/core/types/int32){
    std/num/int32/(==)((std/num/int32/and(i, (std/core/int32(1)))), (std/core/int32(0)));
  };
fun is-odd // inline size: 4
  = fn(i: std/core/types/int32){
    std/num/int32/(==)((std/num/int32/and(i, (std/core/int32(1)))), (std/core/int32(1)));
  };
fun show // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/show((std/core/int.1(i)));
  };
fun show-hex32 // inline size: 8
  = fn(i: std/core/types/int32, width: (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals: (std/core/types/optional :: V -> V)<std/core/types/bool>, pre: (std/core/types/optional :: V -> V)<std/core/types/string>){
    std/core/show-hex((std/num/int32/uint(i)), (std/core/types/Optional<std/core/types/int>((match (width) {
        ((std/core/types/Optional((.width.1913: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .width.1913;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 8;
      }))), (std/core/types/Optional<std/core/types/bool>((match (use-capitals) {
        ((std/core/types/Optional((.use-capitals.1917: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .use-capitals.1917;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/True;
      }))), (std/core/types/Optional<std/core/types/string>((match (pre) {
        ((std/core/types/Optional((.pre.1921: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .pre.1921;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "0x";
      }))));
  };
fun uint32 // inline size: 4
  = fn(i: std/core/types/int){
    std/core/int32((match ((std/core/(>.1)(i, 2147483647))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(-)(i, 4294967296);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> i;
    }));
  };