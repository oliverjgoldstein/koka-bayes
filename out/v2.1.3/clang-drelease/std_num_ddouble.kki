/* Double-double 128-bit floating point numbers.

The `:ddouble` type implements [double double][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:double` values. This extends the precision to 31 decimal digits
(versus 15 for `:double`), but keeps the same range as
a `:double` with a maximum  value of about 1.8&middot;10^308^ (`dd-max`). Because
`:double`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

## Precision {-}

If you add two regular 64-bit `:double` values you can quickly notice the imprecision
due to decimal fractions that cannot be represented precisely. For example:
```
> 0.1 + 0.2
0.30000000000000004
```

This happens because the decimal `0.1` and `0.2` cannot be represented exactly
by a `:double` which is encoded in base 2. For example, if we show `0.1` to 20 digits, we get:
```
> 0.1.show(20)
"0.10000000000000000555"
```

When we convert the constant `0.1` to a `:ddouble` we can see with even more precision how it is
approximated:

```
> 0.1.ddouble
0.1000000000000000055511151231258
```

However, if we convert the number `0.1` directly to a `:ddouble` (instead of going through
a `:double` constant), we can represent `0.1` (almost) exactly:

```
> ddouble("0.1")   // for convenience; using `ddouble-exp(1,-1)` is more efficient
0.1
```

This is possible because a `:ddouble` uses two `:double`s to represent numbers; in this
case the first (_hi_) double is (the inexact) `0.1` while the second one (_lo_) is the
correction to that number. The `show-sum`  (or `show-hex`) function shows this internal pair of numbers:

```
> ddouble("0.1").show-sum(20)
"0.10000000000000000555 + -5.55111512312578301027e-18"

> ddouble("0.1") + ddouble("0.2")
0.3
```

Generally, a `:ddouble` _d_ is represented by a pair of `:double`s, _hi_ and _lo_,
such that _d_ equals _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
Note that despite the extra precision, underflow/overflow and machine precision are
not as well-defined as with a regular `:double` [@lin;@shewchuk;@Dekker].
Nevertheless, using a `:ddouble` often prevents instability in practice over
`:double` computations due to  rounding errors or combining very large and
small numbers.

Take the "thin triangle" problem for example [@Goldberg:float;@Kahan:triangle].
The challenge is to compute
the area of a very thin triangle with sides $a$, $b$, and $c$. The short sides
 $b$ and $c$ are just 3 units in the last place (ulp) shorter than
the longest side $a$. Using the value $s = (a + b + c)/2$, the area of
a triangle is $A = \sqrt{s(s-a)(s-b)(s-c)}$. This is troublesome if $s$ is
close to $a$ since $s-a$ magnifies any rounding error. Let's take $a=7$,
and $b = c = 7/2 + 3\cdot2^{-111}$; according to [@gustafson:posit],
&ldquo;If the units are in light-years, then the short sides are only longer than
half the long side by $1/200$th the diameter of a proton. Yet that pops the triangle
up to about the width of a doorway at the thickest point&rdquo;. Using various
128-bit numbers we get:
````
exact          : 3.14784204874900425235885265494550774498...e-16
128-bit ddouble: 3.147842048749004252358852654945\([47]{color:#F88}\)e-16
128-bit posit  : 3.147842048749004252358852654945507744\([39]{color:#F88}\)e-16
128-bit ieee   : 3.\([63481490842332134725920516158057682878]{color:#F88}\)e-16
````
For this kind of example, a `:ddouble` has better precision than a
regular 128-bit IEEE float since it can combine very large and
small values. (Kahan [@Kahan:triangle] shows how to rewrite the equations
to avoid magnifying rounding errors -- in that case the result for
IEEE 128-bit floats becomes:
````
128-bit ieee x : 3.147842048749004252358852654945507\([92210]{color:#F88}\)e-16
````
)

The implementation is based closely on the [QD] C++ library [@Hida:qd;@Hida:qdlib],
and assumes proper 64-bit IEEE `:double`s with correct rounding.
Integers can be represented precisely up to 30 decimal digits (and a bit more...
up to 2^106^ - 2).

## References {-}

~ Bibliography { caption:"0" }


~~ BibItem { #dekker; bibitem-label:"[1]"; searchterm:"Dekker+A+Floating-Point+Technique+for+Extending+the+Available+Precision" }
T.\ Dekker.
_A Floating-Point Technique for Extending the Available Precision_.
Numerische\ Mathematik, vol. 18 (3), June 1971, 224--242.
[pdf](http://gdz.sub.uni-goettingen.de/dms/resolveppn/?PPN=GDZPPN001170007).
~~

~~ BibItem { #Goldberg:float; bibitem-label:"[2]"}
David Goldberg.
_What Every Computer Scientist Should Know About Floating-point Arithmetic_.
ACM Computing Survey. vol. 23 (1), March 1991. doi: [10.1145/103162.103163](http://doi.org/10.1145/103162.103163).
[pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&rep=rep1&type=pdf).
~~

~~ BibItem { #Gustafson:posit; bibitem-label:"[3]"; searchterm:"Gustafson+John+Beating+floating+point+at+its+own+game+posit+arithmetic"; }
John\ L. Gustafson and Isaac\ Yonemoto.
_Beating Floating Point at its Own Game: Posit Arithmetic_. 2017.
[pdf](http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf).
~~

~~ BibItem { #Hida:qd; bibitem-label:"[4]"; searchterm:"Hida+Quad-Double+Arithmetic:+Algorithms,+Implementation,+and+Application" }
Yozo Hida,\ Xiaoye S.\ Li, and David\ H.\ Bailey.
_Quad-Double Arithmetic: Algorithms, Implementation, and Application_.
Lawrence Berkeley National Laboratory Technical Report LBNL-46996. 2000. [pdf](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.5769).
~~

~~ BibItem { #Hida:qdlib; bibitem-label:"[5]"; searchterm:"Hida+Library+for+double-double+and+quad-double+arithmetic" }
Yozo Hida,\ Xiaoye\ S.\ Li, and David\ H.\ Bailey.
_Library for double-double and quad-double arithmetic._
(2007). [pdf](http://www.jaist.ac.jp/~s1410018/papers/qd.pdf).
~~

~~ Bibitem { #lin; bibitem-label:"[6]"; searchterm:'Linnainmaa+"Software+for+Doubled-Precision+Floating-Point+Computations"' }
Seppo\ Linnainmaa.
_Software for Doubled-Precision Floating-Point Computations_.
ACM Transactions on Mathematical Software (TOMS), vol. 7 (3), Sept. 1981, 272--283.
~~

~~ Bibitem { #Kahan:triangle; bibitem-label:"[7]"}
William\ Kahan.
_Miscalculating Area and Angles of a Needle-like Triangle_.
Lecture notes, 2004, [pdf](https://people.eecs.berkeley.edu/~wkahan/Triangle.pdf).
~~


~~ BibItem { #shewchuk; bibitem-label:"[8]"; }
Jonathan\ Richard\ Shewchuk.
_Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates_.
Discrete & Computational Geometry, vol. 18, 305--363, 1997. [pdf](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
~~

~

[ddwiki]: https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic
[qd]:     http://crd-legacy.lbl.gov/~dhbailey/mpdist

\/
*/
module interface std/num/ddouble
 
//------------------------------
//#kki: import declarations
 
private import std/core/types = std/core/types = "";
private import std/core/hnd = std/core/hnd = "";
private import std/core = std/core = "";
private import std/text/parse = std/text/parse = "";
private import std/num/double = std/num/double = "";
private import std/num/decimal = std/num/decimal = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
/* The `:double` type implements [double double][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:double` values. This extends the precision to 31 decimal digits
(versus 15 for `:double`), but keeps the same range as
a `:double` with a maximum  value of about 1.8&middot;10^308^. Because
`:double`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

Internally a `:ddouble` _d_ is represented as a pair of `:double`s, _hi_ and _lo_,
such that the number represented by _d_ is _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
*/
public value{16,0} type ddouble {
  /* The `:double` type implements [double double][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:double` values. This extends the precision to 31 decimal digits
(versus 15 for `:double`), but keeps the same range as
a `:double` with a maximum  value of about 1.8&middot;10^308^. Because
`:double`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

Internally a `:ddouble` _d_ is represented as a pair of `:double`s, _hi_ and _lo_,
such that the number represented by _d_ is _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
*/
  private con Ddouble(hi: std/core/types/double, lo: std/core/types/double) : (hi : std/core/types/double, lo : std/core/types/double) -> ddouble;
};
private value{16,0} type edouble {
  private con Edouble(num: std/core/types/double, err: std/core/types/double) : (num : std/core/types/double, err : std/core/types/double) -> edouble;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `hi` constructor field of the `:ddouble` type.
private fun hi : (ddouble : ddouble) -> std/core/types/double;
// Automatically generated. Retrieves the `lo` constructor field of the `:ddouble` type.
private fun lo : (ddouble : ddouble) -> std/core/types/double;
public fun .copy : (ddouble, hi : (std/core/types/optional :: V -> V)<std/core/types/double>, lo : (std/core/types/optional :: V -> V)<std/core/types/double>) -> ddouble;
// Automatically generated. Retrieves the `num` constructor field of the `:edouble` type.
private fun num : (edouble : edouble) -> std/core/types/double;
// Automatically generated. Retrieves the `err` constructor field of the `:edouble` type.
private fun err : (edouble : edouble) -> std/core/types/double;
private fun .copy.1 : (edouble, num : (std/core/types/optional :: V -> V)<std/core/types/double>, err : (std/core/types/optional :: V -> V)<std/core/types/double>) -> edouble;
private val maxprecise : std/core/types/int;
// Convert a `:ddouble` to a `:double` (losing precision)
public fun double : (x : ddouble) -> std/core/types/double;
private val dd-default-prec : std/core/types/int;
// maximal precision in decimal digits of a `:ddouble`.
public val dd-max-prec : std/core/types/int;
// Decode a `:ddouble` `d` into two doubles `(hi,lo)` such that `d` equals  `hi`+`lo`,
// where `lo` &le; 0.5&middot;ulp(`hi`).
public fun decode : (d : ddouble) -> (std/core/types/double, std/core/types/double);
// Compare two `:ddouble` values.
public fun compare : (x : ddouble, y : ddouble) -> std/core/types/order;
public fun (!=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
public fun (<=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
public fun (>=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// Is this `:ddouble` equal to is-zero
public fun is-zero : (x : ddouble) -> std/core/types/bool;
// Is this a finite `:ddouble`? (i.e. not `is-nan` or `is-inf`)
public fun is-finite : (x : ddouble) -> std/core/types/bool;
// Is this `:ddouble` negative?
public fun is-neg : (x : ddouble) -> std/core/types/bool;
public fun (==) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// Create a `:ddouble` from a `:double`.
public fun ddouble : (d : std/core/types/double) -> ddouble;
private fun dquicksum : (x : std/core/types/double, y : std/core/types/double) -> ddouble;
// often called `twoproduct` in literature (see [@shewchuk])
private fun prod : (x : std/core/types/double, y : std/core/types/double) -> edouble;
// Multiply two `:ddouble`s
public fun (*) : (x : ddouble, y : ddouble) -> ddouble;
// As `sum` but with `x.abs >= y.abs`
private fun quicksum : (x : std/core/types/double, y : std/core/types/double) -> edouble;
// often called `twosum` in literature (see [@shewchuk])
private fun sum : (x : std/core/types/double, y : std/core/types/double) -> edouble;
// Add two `:ddouble`s
public fun (+) : (x : ddouble, y : ddouble) -> ddouble;
// Negate a `:ddouble`.
public fun (~) : (x : ddouble) -> ddouble;
// Subtract two values.
public fun (-) : (x : ddouble, y : ddouble) -> ddouble;
// Divide two `:ddouble`s
public fun (/) : (x : ddouble, y : ddouble) -> ddouble;
// Return the absolute value.
public fun abs : (x : ddouble) -> ddouble;
// Not-A-Number
public val dd-nan : ddouble;
private val minprecise : std/core/types/int;
private fun is-precise : (i : std/core/types/int) -> std/core/types/bool;
private fun prodsqr : (x : std/core/types/double) -> edouble;
// Multiply `x` with itself.
public fun sqr : (x : ddouble) -> ddouble;
private fun npwr-acc : (x : ddouble, acc : ddouble, n : std/core/types/int) -> ddouble;
// One
public val one : ddouble;
private fun npwr : (x : ddouble, n : std/core/types/int) -> ddouble;
// Return `x` to the power of `n`.
private fun powi : (x : ddouble, n : std/core/types/int) -> ddouble;
// Ten (`10.ddouble`)
public val ten : ddouble;
// Return 10 to the power of `exp`.
private fun powi10 : (exp : std/core/types/int) -> ddouble;
private fun mul-exp10 : (x : ddouble, exp : std/core/types/int) -> ddouble;
private fun small-exp : (i : std/core/types/int, e : std/core/types/int) -> ddouble;
private fun ddouble-int-exp : (i : std/core/types/int, e : std/core/types/int) -> ddouble;
// Create a `:ddouble` from an `:int`.
// A `:ddouble` can represent integers precisely up to 30 digits.
// If an integer is passed that is out of range an infinity is returned.
public fun ddouble.1 : (i : std/core/types/int) -> ddouble;
// monadic lift
private fun .mlift20569-pddouble-normal : (wild_0 : std/core/types/char) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> std/core/types/int;
// monadic lift
private fun .mlift20570-pddouble-normal : (frac : std/core/types/string, neg : std/core/types/bool, whole : std/core/types/string, exp : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20571-pddouble-normal : (wild_ : std/core/types/char) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> std/core/types/string;
// monadic lift
private fun .mlift20572-pddouble-normal : (neg : std/core/types/bool, whole : std/core/types/string, std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20573-pddouble-normal : (neg : std/core/types/bool, whole : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20574-pddouble-normal : (neg : std/core/types/bool) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
private fun pddouble-normal : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20575-pddouble-sum : (hi : std/core/types/double, lo : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20576-pddouble-sum : (hi : std/core/types/double, wild_0 : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
private fun .mlift20577-pddouble-sum : (hi : std/core/types/double) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
private fun pddouble-sum : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
public fun pddouble : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
public fun parse-ddouble : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<ddouble>;
// Parse a floating point number with up to 31 digits precision.
// Return `dd-nan` if the string is an invalid number.
public fun ddouble.2 : (s : std/core/types/string) -> ddouble;
// Decrement by one.
public fun dec : (x : ddouble) -> ddouble;
// Zero constant
public val zero : ddouble;
// Return the sum of a list of doubles.
// Uses [Kahan-Babu&scaron;kan-Neumaier summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)
// to minimize rounding errors. This
// is more precise as Kahan summation and about as fast.\
// `[1.0e3,1.0e97,1.0e3,-1.0e97].sum == 2000.0`\
// A. Neumaier, _Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen_.
// Math. Mechanik, 54:39--51, 1974.
public fun sum.1 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// Is this `:ddouble` positive?
public fun is-pos : (x : ddouble) -> std/core/types/bool;
// Round a `:ddouble` to the nearest integer, rounding to the nearest even number in case of a tie.
public fun round : (x : ddouble) -> ddouble;
// Remainder of two `:ddouble`s
public fun (%) : (x : ddouble, y : ddouble) -> ddouble;
public fun (<) : (x : ddouble, y : ddouble) -> std/core/types/bool;
public fun (>) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// The maximum of `x` and `y`
public fun max : (x : ddouble, y : ddouble) -> ddouble;
// The maximum of the absolute values.
private fun abs-max : (x : ddouble, y : ddouble) -> ddouble;
// The maximum of a list of absolute values.
private fun abs-max.1 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// &pi;
public val dd-pi : ddouble;
// &pi;/2
public val dd-pi2 : ddouble;
// 3&pi;/4
public val dd-pi34 : ddouble;
// &pi;/4
public val dd-pi4 : ddouble;
private val ch-factors : (std/core/list :: V -> V)<ddouble>;
// 2&pi;
public val dd-twopi : ddouble;
// Convert a `:ddouble` to a `:decimal` up to a given precision `prec` (= `-1`).
// A negative precision converts precisely. Returns 0 for non-finite `:ddouble`'s.
public fun decimal : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/num/decimal/decimal;
// Convert a `:ddouble` to the nearest integer (rounding to the nearest even number in case of a tie)
public fun int : (x : ddouble, nonfin : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
private val sin16-table : (std/core/types/vector :: V -> V)<ddouble>;
// Return sin(i*pi/16) for 0 <= i <= 8
private fun sin16 : (i : std/core/types/int) -> ddouble;
private fun dsum : (x : std/core/types/double, y : std/core/types/double) -> ddouble;
// The square root of a non-negative `:ddouble` `x`.
// For negative `x`, `dd-nan` is returned.
public fun sqrt : (x : ddouble) -> ddouble;
// Calculate sine and cosine on an angle in radians.
public fun sincos : (rad : ddouble) -> (ddouble, ddouble);
// Return `x` with the sign of `y`.
public fun with-sign-of : (x : ddouble, y : ddouble) -> ddouble;
// The arc-tangent of a point (`x`,`y`). Returns the angle with respect to the x-axis in radians between -&pi; and &pi;.
public fun atan2 : (y : ddouble, x : ddouble) -> ddouble;
// The arc-cosine of `x`. Returns the angle in radians.
public fun acos : (x : ddouble) -> ddouble;
// The _e_ constant.
public val dd-e : ddouble;
// Negative infinity
public val dd-neginf : ddouble;
// The 'machine epsilon': this is not well-defined for a `:ddouble` in general since
// the difference between 1.0 and the next representable `:ddouble` value is `dd-true-min`.
// Instead, we take the square of `dbl-epsilon`, i.e. 2^-104^.
public val dd-epsilon : ddouble;
// The natural logarithm of 2
public val dd-log2 : ddouble;
// Positive infinity
public val dd-posinf : ddouble;
private fun exp-approx : (p : ddouble, t : ddouble, r : ddouble, eps : std/core/types/double, fs : (std/core/list :: V -> V)<ddouble>, s : (std/core/types/optional :: V -> V)<ddouble>) -> ddouble;
private val exp-factors : (std/core/list :: V -> V)<ddouble>;
// Round to negative infinity.
public fun floor : (x : ddouble) -> ddouble;
// Multiply `x` by a `:double` `p` where `p` must be a power of 2.
private fun mul-pwr2 : (x : ddouble, p : std/core/types/double) -> ddouble;
private fun half : (x : ddouble) -> ddouble;
// 'Load exponent': returns `x`&middot;2^`exp`^.
public fun ldexp : (x : ddouble, exp : std/core/types/int) -> ddouble;
private fun twice : (x : ddouble) -> ddouble;
// Return _e_ (`dd-e`) to the power of `x`.
public fun exp : (x : ddouble) -> ddouble;
// Does `x` equal positive infinity?
public fun is-posinf : (x : ddouble) -> std/core/types/bool;
// The natural logarithm (in base _e_) of `x`.
public fun log : (x : ddouble) -> ddouble;
// The area hyperbolic cosine of `x`.
public fun acosh : (x : ddouble) -> ddouble;
// The arc-sine of `x`. Returns the angle in radians.
public fun asin : (x : ddouble) -> ddouble;
// The area hyperbolic sine of `x`.
public fun asinh : (x : ddouble) -> ddouble;
// The arc-tangent of `x`. Returns the angle in radians.
public fun atan : (x : ddouble) -> ddouble;
// The area hyperbolic tangent of `x`.
public fun atanh : (x : ddouble) -> ddouble;
// Round to positive infinity.
public fun ceiling : (x : ddouble) -> ddouble;
// The cosine function of a given angle in radians.
public fun cos : (rad : ddouble) -> ddouble;
// The hyperbolic sine of `x`.
public fun sinh : (x : ddouble) -> ddouble;
// The hyperbolic cosine of `x`.
public fun cosh : (x : ddouble) -> ddouble;
// 8*dd-epsilon
private val dd-epsilon8 : ddouble;
// [Euler's constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant)
public val dd-euler : ddouble;
// The natural logarithm of 10
public val dd-log10 : ddouble;
// The base-10 logarithm of _e_.
public val dd-log10e : ddouble;
// The base-2 logarithm of _e_.
public val dd-log2e : ddouble;
// The maximum representable `:ddouble`
public val dd-max : ddouble;
// The smallest positive `:ddouble` that is still normalized
public val dd-min : ddouble;
// &pi;/16
private val dd-pi16 : ddouble;
// `1.0 / sqrt(2.0)`
public val dd-sqrt12 : ddouble;
// The square-root of 2
public val dd-sqrt2 : ddouble;
// The smallest positive `:ddouble`  (which is subnormal).
public val dd-true-min : ddouble;
// Create a `:ddouble` `x` such that `x` equals `d`&middot;10^`e`^.
public fun ddouble-exp : (d : std/core/types/double, e : std/core/types/int) -> ddouble;
// Create a `:ddouble` `x` such that `x` equals `i`&middot;10^`e`^.
public fun ddouble-exp.1 : (i : std/core/types/int, exp : std/core/types/int) -> ddouble;
// Division and remainder of two `:ddouble`s
public fun divrem : (x : ddouble, y : ddouble) -> (ddouble, ddouble);
// Encode a `:ddouble` `d` from two doubles `(hi,lo)` such that `d` equals  `hi`+`lo`.
public fun encode : (hi : std/core/types/double, lo : std/core/types/double) -> ddouble;
// `x` to the power of `y` both as `:ddouble`
public fun pow : (x : ddouble, y : ddouble) -> ddouble;
// Return 10 to the power of `exp`.
public fun exp10 : (exp : ddouble) -> ddouble;
private val two : ddouble;
// Return 2 to the power of `exp`.
public fun exp2 : (exp : ddouble) -> ddouble;
// Return `exp(x - 1.0)`.
// Avoids rounding errors for values of `x` very close to `1.0`.
public fun expm1 : (x : ddouble) -> ddouble;
private fun exp2m1 : (x : ddouble) -> ddouble;
// The _floored_ fraction of `x`. This is always positive, such that `x.floor + x.ffraction == x`.
public fun ffraction : (x : ddouble) -> ddouble;
// Round towards zero.
public fun truncate : (x : ddouble) -> ddouble;
// The fraction of `x` such that `x.truncate + x.fraction == x`.
public fun fraction : (x : ddouble) -> ddouble;
// The minimum of `x` and `y`.
public fun min : (x : ddouble, y : ddouble) -> ddouble;
// The hypotenuse of `x` and `y`: `sqrt(x*x + y*y)`.
// Prevents overflow for large numbers.
public fun hypot : (x : ddouble, y : ddouble) -> ddouble;
// The square root of the sum of the squares of three doubles.
// Prevents overflow for large numbers.
public fun hypot.1 : (x : ddouble, y : ddouble, z : ddouble) -> ddouble;
// The square root of the sum of squares of a list of doubles.
// Prevents overflow for large numbers and uses Kahan-Babu&scaron;kan-Neumaier summation
// for precision.
public fun hypot.2 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// Increment by one.
public fun inc : (x : ddouble) -> ddouble;
// Is this an infinite value.
public fun is-inf : (x : ddouble) -> std/core/types/bool;
// Is this `:ddouble` not-a-number?
public fun is-nan : (x : ddouble) -> std/core/types/bool;
// Does `x` equal negative infinity?
public fun is-neginf : (x : ddouble) -> std/core/types/bool;
// Return the sign of the `:ddouble`.
public fun is-sign : (x : ddouble) -> std/core/types/order;
// The logarithm in base 10 of `x`.
public fun log10 : (x : ddouble) -> ddouble;
// Return `log(1.0 + x)`.
// Avoids potential imprecision for small `x` where adding `1.0` explicitly
// may lead to rounding errors.
public fun log1p : (x : ddouble) -> ddouble;
// The logarithm in base 2 of `x`.
public fun log2 : (x : ddouble) -> ddouble;
private fun log2p1 : (x : ddouble) -> ddouble;
// Returns `log(exp(x) + exp(y))`.
// Avoids overlow/underflow errors.
public fun logaddexp : (x : ddouble, y : ddouble) -> ddouble;
// Returns `log2( exp2(x) + exp2(y) )`.
// Avoids overlow/underflow errors.
public fun logaddexp2 : (x : ddouble, y : ddouble) -> ddouble;
// Return if two `:ddouble`s are nearly equal with respect to some `epsilon` (=`8*dd-epsilon`).
// The epsilon is the nearest difference for numbers around 1.0. The routine automatically
// scales the epsilon for larger and smaller numbers, and for numbers close to zero.
public fun nearly-eq : (x : ddouble, y : ddouble, epsilon : (std/core/types/optional :: V -> V)<ddouble>) -> std/core/types/bool;
// The `n`-th root of a `:ddouble` number `x`.
// `n` must be positive, and if `n` is even, then
// `x` must not be negative.
public fun nroot : (x : ddouble, n : std/core/types/int) -> ddouble;
private val one-half : ddouble;
// Round a `:ddouble` to a specified precision.
// Uses `round` if the precision is smaller or equal to zero.
public fun round-to-prec : (x : ddouble, prec : std/core/types/int) -> ddouble;
// Show a `:ddouble` `x` with a given precision `prec` (=`-31`).
// The precision specifies the  number of digits after the dot (in either scientific of fixed-point notation).
// If the precision is negative, _at most_ `prec` digits are displayed, while for a positive
// precision, exactly `prec` digits behind the dot are displayed.
// This uses `show-fixed` when the exponent of `x` in scientific notation is larger than -5
// and smaller than the precision (or 15 in case of a negative precision), otherwise it uses `show-exp`.
public fun show : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a ddouble `x` with a given precision `prec` (=`-31`) in scientific notation.
The precision specifies the  number of digits after the dot, i.e.
the number of significant digits is `prec+1`.
If the precision is negative, _at most_ `prec` digits are displayed, and if
it is positive exactly `prec` digits are used.
```
> 1.1.ddouble.show-exp
"1.1000000000000000888178419700125"
> 1.1.ddouble.show-exp(-100)
"1.100000000000000088817841970012523233890533447265625"
> 1.1.ddouble.show-exp(5)
"1.10000"
> 1.1.ddouble.show-exp(-5)
"1.1"
```
.
*/
public fun show-exp : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a ddouble `x` with a given precision `prec` (=`-31`) in fixed-point notation.
The precision specifies the  number of digits after the dot.
If the precision is negative, _at most_  `prec` digits after the dot are displayed,
while for a positive precision, exactly `prec` digits are used.
```
> 0.1.ddouble.show-fixed
"0.1000000000000000055511151231258"
> 0.1.ddouble.show-fixed(-100)
"0.1000000000000000055511151231257827021181583404541015625"
> 0.1.ddouble.show-fixed(5)
"0.10000"
> 0.1.ddouble.show-fixed(-5)
"0.1"
```
.
*/
public fun show-fixed : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a `:ddouble` `x` precisely as the sum of two `:double`s
in [hexadecimal notation](https://books.google.com/books?id=FgMsCwAAQBAJ&pg=PA41).
Use this if you need to guarantee that you can parse back `:ddouble`s exactly,
i.e. `x == x.show-hex.ddouble`.
```
> 0.1.ddouble.show-hex
"0x1.999999999999Ap-4 + 0x0.0p+0"
> "0.1".ddouble.show-hex
"0x1.999999999999Ap-4 + -0x1.999999999999Ap-58"
> dd-pi.show-hex
"0x1.921FB54442D18p+1 + 0x1.1A62633145C07p-53"
> dd-max.show-hex
"0x1.FFFFFFFFFFFFFp+1023 + 0x1.FFFFFFFFFFFFFp+969"
```
.
*/
public fun show-hex : (x : ddouble, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a `:ddouble` as the sum of  `:double`s with an optional precision.
// Note: use `show-hex` for reliable round-trip parsing.
public fun show-sum : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// The sine function of a given angle in radians.
public fun sin : (rad : ddouble) -> ddouble;
// The tangent of a given angle in radians.
public fun tan : (rad : ddouble) -> ddouble;
// The hyperbolic tangent of `x`.
public fun tanh : (x : ddouble) -> ddouble;
// Return if two `:ddouble`s are nearly equal with respect to an `epsilon` of `10*dd-epsilon`.
// See also `nearly-eq` which takes an explicit `epsilon`.
public fun (~=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline fun hi // inline size: 0
  = fn(ddouble: ddouble){
    match (ddouble) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
inline fun lo // inline size: 0
  = fn(ddouble: ddouble){
    match (ddouble) {
      ((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.x: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: ddouble, hi: (std/core/types/optional :: V -> V)<std/core/types/double>, lo: (std/core/types/optional :: V -> V)<std/core/types/double>){
    std/num/ddouble/Ddouble((match (hi) {
        ((std/core/types/Optional((.hi.179: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> .hi.179;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
               -> .x;
          });
      }), (match (lo) {
        ((std/core/types/Optional((.lo.185: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> .lo.185;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat3: ddouble)
               -> .x0;
          });
      }));
  };
inline fun num // inline size: 0
  = fn(edouble: edouble){
    match (edouble) {
      ((.skip std/num/ddouble/Edouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : edouble ) as .pat: edouble)
         -> .x;
    };
  };
inline fun err // inline size: 0
  = fn(edouble: edouble){
    match (edouble) {
      ((.skip std/num/ddouble/Edouble((.pat0: std/core/types/double) : std/core/types/double, (.x: std/core/types/double) : std/core/types/double) : edouble ) as .pat: edouble)
         -> .x;
    };
  };
fun .copy.1 // inline size: 3
  = fn(.this: edouble, num: (std/core/types/optional :: V -> V)<std/core/types/double>, err: (std/core/types/optional :: V -> V)<std/core/types/double>){
    std/num/ddouble/Edouble((match (num) {
        ((std/core/types/Optional((.num.211: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> .num.211;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Edouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : edouble ) as .pat1: edouble)
               -> .x;
          });
      }), (match (err) {
        ((std/core/types/Optional((.err.217: std/core/types/double) : std/core/types/double) : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> .err.217;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/double> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/double>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Edouble((.pat01: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : edouble ) as .pat3: edouble)
               -> .x0;
          });
      }));
  };
inline val maxprecise // inline size: 0
  = 9007199254740991;
inline fun double // inline size: 0
  = fn(x: ddouble){
    match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
inline val dd-default-prec // inline size: 0
  = -31;
inline val dd-max-prec // inline size: 0
  = 31;
fun decode // inline size: 1
  = fn(d: ddouble){
    std/core/types/(,)<std/core/types/double,std/core/types/double>((match (d) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }), (match (d) {
        ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
           -> .x0;
      }));
  };
fun compare // inline size: 9
  = fn(x: ddouble, y: ddouble){
    match ((match ((std/core/(<.4)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : ddouble ) as .pat3: ddouble)
           -> .x;
      }), (match (y) {
        ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/double) : std/core/types/double, (.pat01: std/core/types/double) : std/core/types/double) : ddouble ) as .pat4: ddouble)
           -> .x0;
      })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.2)((match (x) {
            ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : ddouble ) as .pat3: ddouble)
               -> .x;
          }), (match (y) {
            ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/double) : std/core/types/double, (.pat01: std/core/types/double) : std/core/types/double) : ddouble ) as .pat4: ddouble)
               -> .x0;
          })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    })) {
      ((std/core/types/Eq() : std/core/types/order ) as .pat5: std/core/types/order)
         -> (match ((std/core/(<.4)((match (x) {
            ((.skip std/num/ddouble/Ddouble((.pat03: std/core/types/double) : std/core/types/double, (.x1: std/core/types/double) : std/core/types/double) : ddouble ) as .pat7: ddouble)
               -> .x1;
          }), (match (y) {
            ((.skip std/num/ddouble/Ddouble((.pat04: std/core/types/double) : std/core/types/double, (.x2: std/core/types/double) : std/core/types/double) : ddouble ) as .pat8: ddouble)
               -> .x2;
          })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat6: std/core/types/bool)
             -> std/core/types/Lt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat02: std/core/types/bool)
             -> (match ((std/core/(>.2)((match (x) {
                ((.skip std/num/ddouble/Ddouble((.pat03: std/core/types/double) : std/core/types/double, (.x1: std/core/types/double) : std/core/types/double) : ddouble ) as .pat7: ddouble)
                   -> .x1;
              }), (match (y) {
                ((.skip std/num/ddouble/Ddouble((.pat04: std/core/types/double) : std/core/types/double, (.x2: std/core/types/double) : std/core/types/double) : ddouble ) as .pat8: ddouble)
                   -> .x2;
              })))) {
              ((std/core/types/True() : std/core/types/bool ) as .pat10: std/core/types/bool)
                 -> std/core/types/Gt;
              ((.skip std/core/types/False() : std/core/types/bool ) as .pat20: std/core/types/bool)
                 -> std/core/types/Eq;
            });
        });
      (ord: std/core/types/order)
         -> ord;
    };
  };
fun (!=) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20593 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(!=.1)((std/core/int.5(x0.20593)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (<=) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20595 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(!=.1)((std/core/int.5(x0.20595)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>=) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20597 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(!=.1)((std/core/int.5(x0.20597)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun is-zero // inline size: 1
  = fn(x: ddouble){
    std/core/(==.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun is-finite // inline size: 3
  = fn(x: ddouble){
    match ((std/num/double/is-finite((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/num/double/is-finite((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat2: ddouble)
             -> .x0;
        }));
      (.pat01: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-neg // inline size: 1
  = fn(x: ddouble){
    std/core/(<.4)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun (==) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20605 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(==.1)((std/core/int.5(x0.20605)), (match (std/core/types/Eq) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun ddouble // inline size: 1
  = fn(d: std/core/types/double){
    std/num/ddouble/Ddouble(d, 0.0);
  };
fun dquicksum // inline size: 10
  = fn(x: std/core/types/double, y: std/core/types/double){
    match ((std/core/types/(!)((std/num/double/is-finite(x))))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/ddouble/ddouble(x);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val z : std/core/types/double
              = std/core/(+.3)(x, y);
            val err : std/core/types/double
              = std/core/(-.3)(y, (std/core/(-.3)(z, x)));
        std/num/ddouble/Ddouble(z, (match ((std/num/double/is-finite(z))) {
            ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
               -> err;
            ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
               -> z;
          }));
    };
  };
fun prod // inline size: 4
  = fn(x: std/core/types/double, y: std/core/types/double){
    val z : std/core/types/double
      = std/core/(*.1)(x, y);
    val err : std/core/types/double
      = std/num/double/fmadd(x, y, (std/core/(~.1)(z)));
    std/num/ddouble/Edouble(z, err);
  };
fun quicksum // inline size: 6
  = fn(x: std/core/types/double, y: std/core/types/double){
    val z : std/core/types/double
      = std/core/(+.3)(x, y);
    val err : std/core/types/double
      = std/core/(-.3)(y, (std/core/(-.3)(z, x)));
    std/num/ddouble/Edouble(z, (match ((std/num/double/is-finite(z))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
           -> err;
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
           -> z;
      }));
  };
fun sum // inline size: 9
  = fn(x: std/core/types/double, y: std/core/types/double){
    val z : std/core/types/double
      = std/core/(+.3)(x, y);
    val diff : std/core/types/double
      = std/core/(-.3)(z, x);
    val err : std/core/types/double
      = std/core/(+.3)((std/core/(-.3)(x, (std/core/(-.3)(z, diff)))), (std/core/(-.3)(y, diff)));
    std/num/ddouble/Edouble(z, (match ((std/num/double/is-finite(z))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
           -> err;
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
           -> z;
      }));
  };
fun (~) // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(~.1)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }))), (std/core/(~.1)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
           -> .x0;
      }))));
  };
fun (-) // inline size: 2
  = fn(x: ddouble, y: ddouble){
    std/num/ddouble/(+)(x, (std/num/ddouble/(~)(y)));
  };
fun abs // inline size: 3
  = fn(x: ddouble){
    match ((std/num/ddouble/is-neg(x))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/ddouble/(~)(x);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> x;
    };
  };
inline val minprecise // inline size: 0
  = std/core/(~)(9007199254740991);
fun is-precise // inline size: 4
  = fn(i: std/core/types/int){
    match ((std/core/(>=.1)(i, (std/core/(~)(9007199254740991))))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=.1)(i, 9007199254740991);
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun prodsqr // inline size: 4
  = fn(x: std/core/types/double){
    val z : std/core/types/double
      = std/core/(*.1)(x, x);
    val err : std/core/types/double
      = std/num/double/fmadd(x, x, (std/core/(~.1)(z)));
    std/num/ddouble/Edouble(z, err);
  };
recursive fun npwr-acc // inline size: 10
  = fn(x: ddouble, acc: ddouble, n: std/core/types/int){
    match ((std/core/(<=.1)(n, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> acc;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/is-even(n))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/num/ddouble/npwr-acc((std/num/ddouble/sqr(x)), acc, (std/core/(/)(n, 2)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/num/ddouble/npwr-acc(x, (std/num/ddouble/(*)(x, acc)), (std/core/dec(n)));
        });
    };
  };
inline val one // inline size: 0
  = std/num/ddouble/Ddouble(1.0, 0.0);
fun npwr // inline size: 9
  = fn(x: ddouble, n: std/core/types/int){
    match ((std/core/(==.1)(n, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match ((std/num/ddouble/is-zero(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/num/ddouble/dd-nan;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/num/ddouble/Ddouble(1.0, 0.0);
        });
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> (match ((std/core/(==.1)(n, 1))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat3: std/core/types/bool)
             -> x;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat4: std/core/types/bool)
             -> std/num/ddouble/npwr-acc(x, (std/num/ddouble/Ddouble(1.0, 0.0)), n);
        });
    };
  };
inline val ten // inline size: 0
  = std/num/ddouble/Ddouble(10.0, 0.0);
fun powi10 // inline size: 2
  = fn(exp: std/core/types/int){
    std/num/ddouble/powi((std/num/ddouble/Ddouble(10.0, 0.0)), exp);
  };
fun small-exp // inline size: 5
  = fn(i: std/core/types/int, e: std/core/types/int){
    val dd : ddouble
          = val d.20671 : std/core/types/double
                  = std/core/double(i);
          std/num/ddouble/Ddouble(d.20671, 0.0);
    match ((std/core/is-zero(e))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> dd;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/num/ddouble/mul-exp10(dd, e);
    };
  };
fun ddouble.1 // inline size: 1
  = fn(i: std/core/types/int){
    std/num/ddouble/ddouble-int-exp(i, 0);
  };
fun pddouble // inline size: 1
  = fn<<(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>>>(){
    std/text/parse/(||)<ddouble,(std/core/types/(<>) :: E)>(std/num/ddouble/pddouble-sum, std/num/ddouble/pddouble-normal);
  };
fun ddouble.2 // inline size: 2
  = fn(s: std/core/types/string){
    val m.20742 : (std/core/types/maybe :: V -> V)<ddouble>
          = std/num/ddouble/parse-ddouble(s);
    match (m.20742) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> std/num/ddouble/dd-nan;
      ((.skip std/core/types/Just((x: ddouble) : ddouble) : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat0: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> x;
    };
  };
fun dec // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/(-)(x, (std/num/ddouble/Ddouble(1.0, 0.0)));
  };
inline val zero // inline size: 0
  = std/num/ddouble/Ddouble(0.0, 0.0);
fun is-pos // inline size: 1
  = fn(x: ddouble){
    std/core/(>.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun (%) // inline size: 5
  = fn(x: ddouble, y: ddouble){
    val n : ddouble
      = std/num/ddouble/round((std/num/ddouble/(/)(x, y)));
    val y0.20772 : ddouble
      = std/num/ddouble/(*)(n, y);
    std/num/ddouble/(+)(x, (std/num/ddouble/(~)(y0.20772)));
  };
fun (<) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20773 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(==.1)((std/core/int.5(x0.20773)), (match (std/core/types/Lt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun (>) // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val x0.20775 : std/core/types/order
          = std/num/ddouble/compare(x, y);
    std/core/(==.1)((std/core/int.5(x0.20775)), (match (std/core/types/Gt) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> std/core/(-)(0, 1);
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }));
  };
fun max // inline size: 2
  = fn(x: ddouble, y: ddouble){
    match ((std/num/ddouble/(>=)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun abs-max // inline size: 4
  = fn(x: ddouble, y: ddouble){
    val x0.20777 : ddouble
      = std/num/ddouble/abs(x);
    val y0.20778 : ddouble
      = std/num/ddouble/abs(y);
    match ((std/num/ddouble/(>=)(x0.20777, y0.20778))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x0.20777;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y0.20778;
    };
  };
fun abs-max.1 // inline size: 6
  = fn(xs: (std/core/list :: V -> V)<ddouble>){
    std/core/foldl<ddouble,ddouble,(std/core/types/(<>) :: E)>((std/core/reverse<ddouble>(xs)), (std/num/ddouble/Ddouble(0.0, 0.0)), (fn(x: ddouble, y: ddouble){
        val x1.20784 : ddouble
              = (std/num/ddouble/abs(y));
        (match ((std/num/ddouble/(>=)(x1.20784, x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> x1.20784;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> x;
        });
      }));
  };
inline val dd-pi // inline size: 0
  = std/num/ddouble/Ddouble(3.141592653589793, 1.2246467991473532e-16);
inline val dd-pi2 // inline size: 0
  = std/num/ddouble/Ddouble(1.5707963267948966, 6.123233995736766e-17);
inline val dd-pi34 // inline size: 0
  = std/num/ddouble/Ddouble(2.356194490192345, 9.18485099360515e-17);
inline val dd-pi4 // inline size: 0
  = std/num/ddouble/Ddouble(0.7853981633974483, 3.061616997868383e-17);
inline val dd-twopi // inline size: 0
  = std/num/ddouble/Ddouble(6.283185307179586, 2.4492935982947064e-16);
fun sin16 // inline size: 2
  = fn(i: std/core/types/int){
    val m.20797 : (std/core/types/maybe :: V -> V)<ddouble>
          = std/core/at<ddouble>(std/num/ddouble/sin16-table, i);
    match (m.20797) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> std/num/ddouble/dd-nan;
      ((.skip std/core/types/Just((x: ddouble) : ddouble) : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat0: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> x;
    };
  };
fun dsum // inline size: 9
  = fn(x: std/core/types/double, y: std/core/types/double){
    val z : std/core/types/double
      = std/core/(+.3)(x, y);
    val diff : std/core/types/double
      = std/core/(-.3)(z, x);
    val err : std/core/types/double
      = std/core/(+.3)((std/core/(-.3)(x, (std/core/(-.3)(z, diff)))), (std/core/(-.3)(y, diff)));
    std/num/ddouble/Ddouble(z, (match ((std/num/double/is-finite(z))) {
        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
           -> err;
        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
           -> z;
      }));
  };
fun with-sign-of // inline size: 7
  = fn(x: ddouble, y: ddouble){
    match ((std/num/ddouble/is-neg(y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> val x0.20854 : ddouble
                  = std/num/ddouble/abs(x);
        std/num/ddouble/Ddouble((std/core/(~.1)((match (x0.20854) {
            ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat00: std/core/types/double) : std/core/types/double) : ddouble ) as .pat0: ddouble)
               -> .x;
          }))), (std/core/(~.1)((match (x0.20854) {
            ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
               -> .x0;
          }))));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat02: std/core/types/bool)
         -> std/num/ddouble/abs(x);
    };
  };
inline val dd-e // inline size: 0
  = std/num/ddouble/Ddouble(2.718281828459045, 1.4456468917292502e-16);
inline val dd-epsilon // inline size: 0
  = std/num/ddouble/Ddouble(4.930380657631324e-32, 0.0);
inline val dd-log2 // inline size: 0
  = std/num/ddouble/Ddouble(0.6931471805599453, 2.3190468138462996e-17);
fun mul-pwr2 // inline size: 3
  = fn(x: ddouble, p: std/core/types/double){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
             -> .x;
        }), p)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), p)));
  };
fun half // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
             -> .x;
        }), 0.5)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), 0.5)));
  };
fun ldexp // inline size: 3
  = fn(x: ddouble, exp: std/core/types/int){
    std/num/ddouble/Ddouble((std/num/double/ldexp((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
             -> .x;
        }), exp)), (std/num/double/ldexp((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), exp)));
  };
fun twice // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
             -> .x;
        }), 2.0)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), 2.0)));
  };
fun is-posinf // inline size: 1
  = fn(x: ddouble){
    std/num/double/is-posinf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun atan // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/atan2(x, (std/num/ddouble/Ddouble(1.0, 0.0)));
  };
fun cos // inline size: 1
  = fn(rad: ddouble){
    val .this.20964 : (ddouble, ddouble)
          = std/num/ddouble/sincos(rad);
    match (.this.20964) {
      ((.skip std/core/types/(,)((.pat0: ddouble) : ddouble, (.x: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> .x;
    };
  };
inline val dd-epsilon8 // inline size: 0
  = std/num/ddouble/Ddouble(3.944304526105059e-31, 0.0);
inline val dd-euler // inline size: 0
  = std/num/ddouble/Ddouble(0.5772156649015329, -4.942915152430645e-18);
inline val dd-log10 // inline size: 0
  = std/num/ddouble/Ddouble(2.302585092994046, -2.1707562233822494e-16);
inline val dd-log10e // inline size: 0
  = std/num/ddouble/Ddouble(0.4342944819032518, 1.098319650216765e-17);
inline val dd-log2e // inline size: 0
  = std/num/ddouble/Ddouble(1.4426950408889634, 2.035527374093103e-17);
inline val dd-max // inline size: 0
  = std/num/ddouble/Ddouble(1.7976931348623157e308, 9.979201547673598e291);
inline val dd-min // inline size: 0
  = std/num/ddouble/Ddouble(2.2250738585072014e-308, 0.0);
inline val dd-pi16 // inline size: 0
  = std/num/ddouble/Ddouble(3.141592653589793, 1.2246467991473532e-16);
inline val dd-sqrt12 // inline size: 0
  = std/num/ddouble/Ddouble(0.7071067811865476, -4.833646656726457e-17);
inline val dd-sqrt2 // inline size: 0
  = std/num/ddouble/Ddouble(1.4142135623730951, -9.667293313452913e-17);
inline val dd-true-min // inline size: 0
  = std/num/ddouble/Ddouble(5.0e-324, 0.0);
fun divrem // inline size: 6
  = fn(x: ddouble, y: ddouble){
    val n : ddouble
          = std/num/ddouble/round((std/num/ddouble/(/)(x, y)));
    std/core/types/(,)<ddouble,ddouble>(n, val y0.20995 : ddouble
                                                 = (std/num/ddouble/(*)(n, y));
      (std/num/ddouble/(+)(x, (std/num/ddouble/(~)(y0.20995)))));
  };
fun encode // inline size: 3
  = fn(hi: std/core/types/double, lo: std/core/types/double){
    std/num/ddouble/(+)((std/num/ddouble/ddouble(hi)), (std/num/ddouble/ddouble(lo)));
  };
fun exp10 // inline size: 2
  = fn(exp: ddouble){
    std/num/ddouble/pow((std/num/ddouble/Ddouble(10.0, 0.0)), exp);
  };
inline val two // inline size: 0
  = std/num/ddouble/Ddouble(2.0, 0.0);
fun exp2 // inline size: 2
  = fn(exp: ddouble){
    std/num/ddouble/pow((std/num/ddouble/Ddouble(2.0, 0.0)), exp);
  };
fun ffraction // inline size: 3
  = fn(x: ddouble){
    val y.21007 : ddouble
          = std/num/ddouble/floor(x);
    std/num/ddouble/(+)(x, (std/num/ddouble/(~)(y.21007)));
  };
fun truncate // inline size: 4
  = fn(x: ddouble){
    match ((std/num/ddouble/is-neg(x))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/ddouble/ceiling(x);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/num/ddouble/floor(x);
    };
  };
fun fraction // inline size: 3
  = fn(x: ddouble){
    val y.21009 : ddouble
          = std/num/ddouble/truncate(x);
    std/num/ddouble/(+)(x, (std/num/ddouble/(~)(y.21009)));
  };
fun min // inline size: 2
  = fn(x: ddouble, y: ddouble){
    match ((std/num/ddouble/(<=)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun inc // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/(+)(x, (std/num/ddouble/Ddouble(1.0, 0.0)));
  };
fun is-inf // inline size: 1
  = fn(x: ddouble){
    std/num/double/is-inf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun is-nan // inline size: 3
  = fn(x: ddouble){
    match ((std/num/double/is-nan((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/True;
      (.pat00: std/core/types/bool)
         -> std/num/double/is-nan((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/double) : std/core/types/double, (.x0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat2: ddouble)
             -> .x0;
        }));
    };
  };
fun is-neginf // inline size: 1
  = fn(x: ddouble){
    std/num/double/is-neginf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun is-sign // inline size: 4
  = fn(x: ddouble){
    match ((std/core/(==.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/double) : std/core/types/double, (.pat0: std/core/types/double) : std/core/types/double) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/Eq;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
         -> (match ((std/core/(<.4)((match (x) {
            ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/double) : std/core/types/double, (.pat01: std/core/types/double) : std/core/types/double) : ddouble ) as .pat2: ddouble)
               -> .x0;
          }), 0.0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat10: std/core/types/bool)
             -> std/core/types/Lt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat20: std/core/types/bool)
             -> std/core/types/Gt;
        });
    };
  };
fun log10 // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/(/)((std/num/ddouble/log(x)), (std/num/ddouble/Ddouble(2.302585092994046, -2.1707562233822494e-16)));
  };
fun log2 // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/(/)((std/num/ddouble/log(x)), (std/num/ddouble/Ddouble(0.6931471805599453, 2.3190468138462996e-17)));
  };
inline val one-half // inline size: 0
  = std/num/ddouble/Ddouble(0.5, 0.0);
fun round-to-prec // inline size: 9
  = fn(x: ddouble, prec: std/core/types/int){
    match ((std/core/(<=.1)(prec, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/num/ddouble/round(x);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.1)(prec, 31))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> x;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> val p : ddouble
                      = std/num/ddouble/powi10(prec);
            std/num/ddouble/(/)((std/num/ddouble/round((std/num/ddouble/(*)(x, p)))), p);
        });
    };
  };
fun sin // inline size: 1
  = fn(rad: ddouble){
    val .this.21084 : (ddouble, ddouble)
          = std/num/ddouble/sincos(rad);
    match (.this.21084) {
      ((.skip std/core/types/(,)((.x: ddouble) : ddouble, (.pat0: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> .x;
    };
  };
fun tan // inline size: 2
  = fn(rad: ddouble){
    match ((std/num/ddouble/sincos(rad))) {
      ((.skip std/core/types/(,)(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/double) : std/core/types/double, (.pat1: std/core/types/double) : std/core/types/double) : ddouble ) as s: ddouble) : ddouble, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/double) : std/core/types/double, (.pat3: std/core/types/double) : std/core/types/double) : ddouble ) as c: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> std/num/ddouble/(/)(s, c);
    };
  };
fun (~=) // inline size: 1
  = fn(x: ddouble, y: ddouble){
    std/num/ddouble/nearly-eq(x, y, (std/core/types/None<ddouble>));
  };